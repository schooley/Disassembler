00001246 Starting Address
Assembler used: EASy68K Editor/Assembler v5.13.01
Created On: 12/30/2013 8:25:26 PM

00000000                             1  
00000000                             2  *---------------------------------------------------------------------------------------
00000000                             3  * Title        : 3BDISS
00000000                             4  * Written by   : Joseph Schooley
00000000                             5  * Contributors : Nguyen Tong (testing, IO), Terence Calhoun (testing, EA)
00000000                             6  * Date         : 12/30/2013
00000000                             7  * Description  : A Motorola MC68000 Microprocessor disassembler that diassembles itself
00000000                             8  *--------------------------------------------------------------------------------------
00001000                             9          ORG     $1000
00001000  =0000000D                 10  CR      EQU     $0D         ASCII: carriage return
00001000  =0000000A                 11  LF      EQU     $0A         ASCII: line feed
00001000                            12  
00001000                            13  GBUFF   DS.L    1           Pointer to next location in "Good buffer"
00001004                            14  NGBUFF  DS.L    1           Pointer to next location after the first displayed instruction
00001008                            15  
00001008                            16  *-----I/O Memory-----
00001008                            17  IOOPCD  DS.W    1           IO offset value for OPNAME, or FF if none
0000100A                            18  IOBDCD  DS.W    1           IO offset value for BAD OPNAME, or FF if none
0000100C                            19  IOSIZE  DS.B    1           IO size for OP code, or FF if none
0000100E                            20  IOADDR  DS.L    1           IO address value for instruction memory location
00001012                            21  IOLC    DS.B    1           IO line counter for screen
00001013                            22  IOBC    DS.B    1           IO BAD counter
00001014                            23  
00001014                            24  COMMENT DS.B    16          IO annotated comments
00001024= 2E 2E 2E 00               25          DC.B    '...',0     Last 4 bytes are trailing periods if comment is too long
00001028                            26  
00001028                            27  * OP code name memory
00001028                            28  *                NAME           DEC     HEX
00001028= 41 44 44 00               29  OPNAME  DC.B    'ADD',0         000     000
0000102C= 41 44 44 41 00            30          DC.B    'ADDA',0        004     004
00001031= 41 44 44 49 00            31          DC.B    'ADDI',0        009     009
00001036= 41 44 44 51 00            32          DC.B    'ADDQ',0        014     00e
0000103B= 41 4E 44 00               33          DC.B    'AND',0         019     013
0000103F= 41 4E 44 49 00            34          DC.B    'ANDI',0        023     017
00001044= 41 53 4C 00               35          DC.B    'ASL',0         028     01c
00001048= 41 53 52 00               36          DC.B    'ASR',0         032     020
0000104C= 42 53 52 00               37          DC.B    'BSR',0         036     024
00001050= 42 54 53 54 00            38          DC.B    'BTST',0        040     028
00001055= 43 4C 52 00               39          DC.B    'CLR',0         045     02d
00001059= 43 4D 50 00               40          DC.B    'CMP',0         049     031
0000105D= 43 4D 50 41 00            41          DC.B    'CMPA',0        053     035
00001062= 43 4D 50 49 00            42          DC.B    'CMPI',0        058     03a
00001067= 44 41 54 41 00            43          DC.B    'DATA',0        063     03f
0000106C= 44 42 43 43 00            44          DC.B    'DBCC',0        068     044
00001071= 44 42 43 53 00            45          DC.B    'DBCS',0        073     049
00001076= 44 42 45 51 00            46          DC.B    'DBEQ',0        078     04e
0000107B= 44 42 47 45 00            47          DC.B    'DBGE',0        083     053
00001080= 44 42 47 54 00            48          DC.B    'DBGT',0        088     058
00001085= 44 42 48 49 00            49          DC.B    'DBHI',0        093     05d
0000108A= 44 42 4C 45 00            50          DC.B    'DBLE',0        098     062
0000108F= 44 42 4C 53 00            51          DC.B    'DBLS',0        103     067
00001094= 44 42 4C 54 00            52          DC.B    'DBLT',0        108     06c
00001099= 44 42 4D 49 00            53          DC.B    'DBMI',0        113     071
0000109E= 44 42 4E 45 00            54          DC.B    'DBNE',0        118     076
000010A3= 44 42 50 4C 00            55          DC.B    'DBPL',0        123     07b
000010A8= 44 42 52 41 00            56          DC.B    'DBRA',0        128     080
000010AD= 44 42 56 43 00            57          DC.B    'DBVC',0        133     085
000010B2= 44 42 56 53 00            58          DC.B    'DBVS',0        138     08a
000010B7= 44 49 56 53 00            59          DC.B    'DIVS',0        143     08f
000010BC= 44 49 56 55 00            60          DC.B    'DIVU',0        148     094
000010C1= 45 4F 52 00               61          DC.B    'EOR',0         153     099
000010C5= 45 4F 52 49 00            62          DC.B    'EORI',0        157     09d
000010CA= 4A 4D 50 00               63          DC.B    'JMP',0         162     0a2
000010CE= 4A 53 52 00               64          DC.B    'JSR',0         166     0a6
000010D2= 4C 45 41 00               65          DC.B    'LEA',0         170     0aa
000010D6= 4C 53 4C 00               66          DC.B    'LSL',0         174     0ae
000010DA= 4C 53 52 00               67          DC.B    'LSR',0         178     0b2
000010DE= 4D 4F 56 45 00            68          DC.B    'MOVE',0        182     0b6
000010E3= 4D 4F 56 45 41 00         69          DC.B    'MOVEA',0       187     0bb
000010E9= 4D 4F 56 45 4D 00         70          DC.B    'MOVEM',0       193     0c1
000010EF= 4D 4F 56 45 51 00         71          DC.B    'MOVEQ',0       199     0c7
000010F5= 4D 55 4C 53 00            72          DC.B    'MULS',0        205     0cd
000010FA= 4D 55 4C 55 00            73          DC.B    'MULU',0        210     0d2
000010FF= 4E 4F 50 00               74          DC.B    'NOP',0         215     0d7
00001103= 4E 4F 54 00               75          DC.B    'NOT',0         219     0db
00001107= 52 4F 4C 00               76          DC.B    'ROL',0         223     0df
0000110B= 52 4F 52 00               77          DC.B    'ROR',0         227     0e3
0000110F= 52 54 44 00               78          DC.B    'RTD',0         231     0e7
00001113= 52 54 45 00               79          DC.B    'RTE',0         235     0eb
00001117= 52 54 52 00               80          DC.B    'RTR',0         239     0ef
0000111B= 52 54 53 00               81          DC.B    'RTS',0         243     0f3
0000111F= 53 55 42 00               82          DC.B    'SUB',0         247     0f7
00001123= 53 55 42 41 00            83          DC.B    'SUBA',0        251     0fb
00001128= 53 55 42 49 00            84          DC.B    'SUBI',0        256     100
0000112D= 53 55 42 51 00            85          DC.B    'SUBQ',0        261     105
00001132= 53 57 41 50 00            86          DC.B    'SWAP',0        266     10a
00001137= 54 52 41 50 00            87          DC.B    'TRAP',0        271     10f
0000113C= 44 42 54 00               88          DC.B    'DBT',0         276     114
00001140= 44 42 46 00               89          DC.B    'DBF',0         280     118
00001144= 45 58 54 00               90          DC.B    'EXT',0         284     11C
00001148= 4E 45 47 00               91          DC.B    'NEG',0         288     120
0000114C                            92  
0000114C= 2E 42 00                  93  IOOPSZ  DC.B    '.B',0          0       00
0000114F= 2E 57 00                  94          DC.B    '.W',0          3       03
00001152= 2E 4C 00                  95          DC.B    '.L',0          6       06
00001155= 20 20 00                  96          DC.B    '  ',0          9       09
00001158                            97  
00001158                            98  *-----EA Memory------
00001158                            99  DMD     DS.B    1               Destination mode
00001159                           100  DRG     DS.B    1               Destination register
0000115A                           101  SMD     DS.B    1               Source mode
0000115B                           102  SRG     DS.B    1               Source register
0000115C                           103  RGMD    DS.B    1               Last register + mod (00REGMOD)
0000115D                           104  DIS     DS.B    1               Last displacement
0000115E                           105  
0000115E                           106  *--------------------
0000115E                           107  *                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
0000115E= 50 72 65 73 73 20 ...    108  MSSG4   DC.B    'Press [ENTER] for the next page, or [CTRL] + [ENTER] for next line.',0
000011A2= 59 6F 75 20 68 61 ...    109  MSSG5   DC.B    'You have reached the end of the program. Press any key to restart, or 0 to quit.',0
000011F3= 41 64 64 72 65 73 ...    110  HEADR   DC.B    'Address  --------Code-------- OP-code -------Operand------- -Annotated Comments- ',0
00001245                           111  *                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
00001245                           112  
00001245                           113  
00001246  11FC 0000 1012           114  START   MOVE.B  #0,IOLC             Set line counter to 0
0000124C  11FC 0000 1013           115          MOVE.B  #0,IOBC             Set bad counter to 0
00001252  21FC 00001246 1000       116          MOVE.L  #START,(GBUFF)      Store starting location in GBUFF for OP
0000125A  21FC 00001246 1004       117          MOVE.L  #START,(NGBUFF)     Copy to NGBUFF
00001262  11FC 0000 1014           118          MOVE.B  #0,(COMMENT)        Set first comment to NULL
00001268  103C 000B                119          MOVE.B  #11,D0              Clear the screen
0000126C  323C FF00                120          MOVE.W  #$FF00,D1
00001270  4E4F                     121          TRAP    #15
00001272  103C 000C                122          MOVE.B  #12,D0              Keyboard echo
00001276  123C 0001                123          MOVE.B  #1,D1               Visible
0000127A  4E4F                     124          TRAP    #15
0000127C  2E7C 01000000            125          MOVEA.L #$01000000,A7       Reset stack pointer
00001282  6000 0B50                126          BRA     DSPHDR              Branch to display header
00001286                           127  
00001286                           128  *-----------------------------------
00001286                           129  *    Conversion & Comparison Methods
00001286                           130  *-----------------------------------
00001286                           131  
00001286                           132  *
00001286                           133  * Flag set / clear: Sets or clears the flag
00001286                           134  *
00001286                           135   
00001286  44FC 0004                136  FLAGST  MOVE.W  #%100,CCR       Set the z-flag
0000128A  4E75                     137          RTS                     Return to caller
0000128C  44FC 0000                138  FLAGCL  MOVE.W  #%000,CCR       Clear the z-flg
00001290  4E75                     139          RTS                     Return to caller
00001292                           140  
00001292                           141  *
00001292                           142  * ASCII2HEX: Convert ASCII into HEX.
00001292                           143  * Input ASCII from D0 output HEX to D1
00001292                           144  *
00001292                           145  
00001292                           146  ASCII2HEX
00001292  2200                     147          MOVE.L  D0,D1           Move the input to D1
00001294  0441 3030                148          SUB     #$3030,D1       Convert last word
00001298  4841                     149          SWAP    D1              Swap bytes
0000129A  0441 3030                150          SUB     #$3030,D1       Convert first word
0000129E  4841                     151          SWAP    D1              Restore order
000012A0                           152          
000012A0  2F02                     153          MOVE.L  D2,-(SP)        Push D2 on stack
000012A2  4282                     154          CLR.L   D2              
000012A4  143C 0003                155          MOVE.B  #3,D2           Set rotation count
000012A8                           156          
000012A8  6100 001A                157          BSR     A2H             Start loop
000012AC                           158          
000012AC  241F                     159          MOVE.L  (SP)+,D2        Restore D2
000012AE                           160                  
000012AE                           161                                * XAXBXCXD
000012AE  E919                     162          ROL.B   #4,D1           XAXBXCDX
000012B0  E949                     163          LSL.W   #4,D1           XAXBCDX0
000012B2  E159                     164          ROL.W   #8,D1           XAXBX0CD
000012B4  4841                     165          SWAP    D1              X0CDXAXB
000012B6  E919                     166          ROL.B   #4,D1           X0CDXABX
000012B8  E949                     167          LSL.W   #4,D1           X0CDABX0
000012BA  E189                     168          LSL.L   #8,D1           CDABX000
000012BC  4241                     169          CLR.W   D1              CDAB0000
000012BE  4841                     170          SWAP    D1              0000CDAB
000012C0  E159                     171          ROL.W   #8,D1           0000ABCD
000012C2  4E75                     172          RTS                     Return to caller
000012C4                           173          
000012C4                           174          
000012C4                           175  A2H   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
000012C4  B23C 0011                176          CMP.B   #$11,D1         11 = A
000012C8  6700 0032                177          BEQ     A2H11
000012CC  B23C 0012                178          CMP.B   #$12,D1         12 = B
000012D0  6700 0030                179          BEQ     A2H12
000012D4  B23C 0013                180          CMP.B   #$13,D1         13 = C
000012D8  6700 002E                181          BEQ     A2H13
000012DC  B23C 0014                182          CMP.B   #$14,D1         14 = D
000012E0  6700 002C                183          BEQ     A2H14
000012E4  B23C 0015                184          CMP.B   #$15,D1         15 = E
000012E8  6700 002A                185          BEQ     A2H15
000012EC  B23C 0016                186          CMP.B   #$16,D1         16 = F
000012F0  6700 0028                187          BEQ     A2H16
000012F4                           188          
000012F4                           189  A2HADV  * A2H conversion branch helper: Rotate to the next byte, and loop back to A2H until all bytes have been analyzed/converted
000012F4  E199                     190          ROL.L   #8,D1           Rotate 1st byte to the end
000012F6  51CA FFCC                191          DBRA    D2,A2H          If count is > 0, decrement and loop back to A2H
000012FA  4E75                     192          RTS                     If count == 0, return to sub-routine
000012FC                           193  
000012FC                           194  * A2H conversion branches
000012FC  123C 000A                195  A2H11   MOVE.B  #$A,D1
00001300  60F2                     196          BRA     A2HADV
00001302  123C 000B                197  A2H12   MOVE.B  #$B,D1
00001306  60EC                     198          BRA     A2HADV
00001308  123C 000C                199  A2H13   MOVE.B  #$C,D1
0000130C  60E6                     200          BRA     A2HADV
0000130E  123C 000D                201  A2H14   MOVE.B  #$D,D1
00001312  60E0                     202          BRA     A2HADV
00001314  123C 000E                203  A2H15   MOVE.B  #$E,D1
00001318  60DA                     204          BRA     A2HADV
0000131A  123C 000F                205  A2H16   MOVE.B  #$F,D1
0000131E  60D4                     206          BRA     A2HADV
00001320                           207  
00001320                           208  *
00001320                           209  * HEX2ASCII: Convert HEX into ASCII.
00001320                           210  * Input HEX from D0.W output ASCII to D1.L
00001320                           211  *
00001320                           212  
00001320                           213  HEX2ASCII
00001320  2200                     214          MOVE.L  D0,D1           Move the input to D1
00001322                           215  
00001322                           216                                * XXXXABCD
00001322  4841                     217          SWAP    D1              ABCDXXXX
00001324  4241                     218          CLR.W   D1              ABCD0000
00001326  E999                     219          ROL.L   #4,D1           BCD0000A
00001328  E909                     220          LSL.B   #4,D1           BCD000A0
0000132A  E159                     221          ROL.W   #8,D1           BCD0A000
0000132C  E999                     222          ROL.L   #4,D1           CD0A000B
0000132E  E159                     223          ROL.W   #8,D1           CD0A0B00
00001330  E999                     224          ROL.L   #4,D1           D0A0B00C
00001332  E909                     225          LSL.B   #4,D1           D0A0B0C0
00001334  E999                     226          ROL.L   #4,D1           0A0B0C0D
00001336                           227  
00001336  2F02                     228          MOVE.L  D2,-(SP)        Push D2 on stack
00001338  4282                     229          CLR.L   D2              
0000133A  143C 0003                230          MOVE.B  #3,D2           Set rotation count
0000133E  6100 0012                231          BSR     H2A             Start loop
00001342  241F                     232          MOVE.L  (SP)+,D2        Restore D2
00001344                           233  
00001344  0641 3030                234          ADD     #$3030,D1       Convert last word
00001348  4841                     235          SWAP    D1              Swap bytes
0000134A  0641 3030                236          ADD     #$3030,D1       Convert first word
0000134E  4841                     237          SWAP    D1              Restore order
00001350  4E75                     238          RTS                     Return to caller
00001352                           239          
00001352                           240          
00001352                           241  H2A   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
00001352  B23C 000A                242          CMP.B   #$A,D1         A = 11
00001356  6700 0032                243          BEQ     H2AA
0000135A  B23C 000B                244          CMP.B   #$B,D1         B = 12
0000135E  6700 0030                245          BEQ     H2AB
00001362  B23C 000C                246          CMP.B   #$C,D1         C = 13
00001366  6700 002E                247          BEQ     H2AC
0000136A  B23C 000D                248          CMP.B   #$D,D1         D = 14
0000136E  6700 002C                249          BEQ     H2AD
00001372  B23C 000E                250          CMP.B   #$E,D1         E = 15
00001376  6700 002A                251          BEQ     H2AE
0000137A  B23C 000F                252          CMP.B   #$F,D1         F = 16
0000137E  6700 0028                253          BEQ     H2AF
00001382                           254          
00001382                           255  H2AADV  * H2A conversion branch helper: Rotate to the next byte, and loop back to H2A until all bytes have been analyzed/converted
00001382  E199                     256          ROL.L   #8,D1           Rotate 1st byte to the end
00001384  51CA FFCC                257          DBRA    D2,H2A          If count is > 0, decrement and loop back to A2H
00001388  4E75                     258          RTS                     If count == 0, return to sub-routine
0000138A                           259  
0000138A                           260  * H2A conversion branches
0000138A  123C 0011                261  H2AA    MOVE.B  #$11,D1
0000138E  60F2                     262          BRA     H2AADV
00001390  123C 0012                263  H2AB    MOVE.B  #$12,D1
00001394  60EC                     264          BRA     H2AADV
00001396  123C 0013                265  H2AC    MOVE.B  #$13,D1
0000139A  60E6                     266          BRA     H2AADV
0000139C  123C 0014                267  H2AD    MOVE.B  #$14,D1
000013A0  60E0                     268          BRA     H2AADV
000013A2  123C 0015                269  H2AE    MOVE.B  #$15,D1
000013A6  60DA                     270          BRA     H2AADV
000013A8  123C 0016                271  H2AF    MOVE.B  #$16,D1
000013AC  60D4                     272          BRA     H2AADV
000013AE                           273  
000013AE                           274  
000013AE                           275  *
000013AE                           276  * Mask: Mask an input
000013AE                           277  * Input value from D0, input mask from D2, output masked value to D1
000013AE                           278  *
000013AE                           279  
000013AE  2200                     280  MASK    MOVE.L  D0,D1           Move the input to D1
000013B0  C282                     281          AND.L   D2,D1           Perform AND on input with the mask
000013B2  4E75                     282          RTS                     Return to caller
000013B4                           283  
000013B4                           284  *
000013B4                           285  * Test Mask: Test an input to a mask.
000013B4                           286  * Input value from D0, input mask from D2, and modify z-flag
000013B4                           287  *
000013B4                           288  
000013B4  2F01                     289  TSTMSK  MOVE.L  D1,-(SP)        Push D1 on stack
000013B6  61F6                     290          BSR     MASK            Mask the input
000013B8  B481                     291          CMP.L   D1,D2           Test if the input matched the mask
000013BA  6606                     292          BNE     *+8             If it didn't match, skip two lines
000013BC  221F                     293          MOVE.L  (SP)+,D1        Restore D1
000013BE  6000 FEC6                294          BRA     FLAGST          Set flag & return to caller
000013C2  221F                     295          MOVE.L  (SP)+,D1        Restore D1
000013C4  6000 FEC6                296          BRA     FLAGCL          Clear flag & return to caller
000013C8                           297  
000013C8                           298  *
000013C8                           299  * Compare Mask: Strictly test an input to two masks allowing don't cares.
000013C8                           300  * Input value from D0, input 1 mask from D2, input 0 mask from D3, and modify z-flag
000013C8                           301  *
000013C8                           302  
000013C8  48E7 F800                303  CMPMSK  MOVEM.L D0-D4,-(SP)     Push D1-D4 on stack
000013CC  2800                     304          MOVE.L  D0,D4           Copy input to D4
000013CE  C082                     305          AND.L   D2,D0           AND 1 mask to input
000013D0  B480                     306          CMP.L   D0,D2           Compare masked input to 1 mask
000013D2  6708                     307          BEQ     *+10            If it matched, skip two lines
000013D4  4CDF 001F                308          MOVEM.L (SP)+,D0-D4     If it didn't match, restore D1-D4
000013D8  6000 FEB2                309          BRA     FLAGCL          Clear flag & return to caller
000013DC  2004                     310          MOVE.L  D4,D0           Restore input
000013DE  4680                     311          NOT.L   D0              !input
000013E0  C083                     312          AND.L   D3,D0           AND 0 mask on input; effectively, NOR 0 mask to the input
000013E2  B680                     313          CMP.L   D0,D3           Compare masked input to 0 mask
000013E4  6608                     314          BNE     *+10            If it didn't match, skip to clear flag
000013E6  4CDF 001F                315          MOVEM.L (SP)+,D0-D4     If it matched, restore D1-D4
000013EA  6000 FE9A                316          BRA     FLAGST          Set flag & return to caller
000013EE  4CDF 001F                317          MOVEM.L (SP)+,D0-D4     Restore D1-D4
000013F2  6000 FE98                318          BRA     FLAGCL          Clear flag & return to caller
000013F6                           319  
000013F6                           320  *        
000013F6                           321  * Extract Mask: Test an input to a subsequent mask, and return the masked value in LSB format
000013F6                           322  * Input value from D0, input mask from D2, output value in D1
000013F6                           323  *
000013F6                           324  
000013F6  2F02                     325  EXTMSK  MOVE.L  D2,-(SP)        Push D2 on stack
000013F8  2200                     326          MOVE.L  D0,D1           Move the input to D1
000013FA  C282                     327          AND.L   D2,D1           Perform AND on input with the mask
000013FC  0802 0000                328  EXTLP   BTST.L  #0,D2           Test the LSB of the mask for 0
00001400  6700 0006                329          BEQ     EXTADV          If it is 0, rotate the mask until it is 1
00001404  241F                     330          MOVE.L  (SP)+,D2        Restore the mask
00001406  4E75                     331          RTS                     Return to caller
00001408                           332          
00001408  E28A                     333  EXTADV  LSR.L   #1,D2           Rotate mask right by 1 bit
0000140A  E299                     334          ROR.L   #1,D1           Rotate output in sync with mask
0000140C  60EE                     335          BRA     EXTLP           Return to loop
0000140E                           336  
0000140E                           337  *
0000140E                           338  * Display ASCII: Display the ASCII from D0.L to screen
0000140E                           339  *
0000140E  48E7 E000                340  DSPAX   MOVEM.L D0-D2,-(SP)     Push D0-D2
00001412  2200                     341          MOVE.L  D0,D1
00001414  6000 0044                342          BRA     DSPHST          Branch to DISPHX Start
00001418                           343  
00001418                           344  *
00001418                           345  * Display HEX Address: Display the hex from A1 according to the byte length in D2.L
00001418                           346  *
00001418                           347  
00001418  48E7 E040                348  DSPHXA  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
0000141C  51CA 0006                349  DSPHXLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001420  6000 0016                350          BRA     DSPHXRT         If count is <= 0, branch to return
00001424  1019                     351          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
00001426  6100 FEF8                352          BSR     HEX2ASCII       Get ASCII in D1
0000142A  E159                     353          ROL.W   #8,D1           Read first byte
0000142C  103C 0006                354          MOVE.B  #6,D0           Display char from D1.B
00001430  4E4F                     355          TRAP    #15
00001432  E159                     356          ROL.W   #8,D1           Read second byte
00001434  4E4F                     357          TRAP    #15
00001436  60E4                     358          BRA     DSPHXLP         Loop back
00001438  4CDF 0207                359  DSPHXRT MOVEM.L (SP)+,D0-D2/A1  Else, restore values
0000143C  4E75                     360          RTS                     Return to caller
0000143E                           361  
0000143E                           362  
0000143E                           363  *
0000143E                           364  * Display HEX Byte: Display the hex from D0.B to screen
0000143E                           365  *
0000143E                           366  
0000143E  48E7 C000                367  DSPHXB  MOVEM.L D0/D1,-(SP)     Push D0 and D1 to stack
00001442  6100 FEDC                368          BSR     HEX2ASCII       Get ASCII in D1
00001446  103C 0006                369          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
0000144A  4E4F                     370          TRAP    #15
0000144C  4CDF 0003                371          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
00001450  4E75                     372          RTS                     Return to caller
00001452                           373  
00001452                           374  *
00001452                           375  * Display HEX Word: Display the hex from D0.W to screen
00001452                           376  *
00001452                           377  
00001452  48E7 E000                378  DSPHXW  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
00001456  6100 FEC8                379          BSR     HEX2ASCII       Get ASCII in D1
0000145A                           380  
0000145A  4282                     381  DSPHST  CLR.L   D2              
0000145C  143C 0003                382          MOVE.B  #3,D2           Set rotation count
00001460  103C 0006                383          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
00001464  6100 0008                384          BSR     DSPHADV         Start loop
00001468                           385  
00001468  4CDF 0007                386          MOVEM.L  (SP)+,D0-D2    Restore D0-D2
0000146C  4E75                     387          RTS                     Return to caller
0000146E                           388  
0000146E  E199                     389  DSPHADV ROL.L   #8,D1           Rotate bytes left
00001470  4E4F                     390          TRAP    #15             Display char in D1.B
00001472  51CA FFFA                391          DBRA    D2,DSPHADV      If count is > 0, decrement and loop back to DSPHADV
00001476  4E75                     392          RTS                     If count == 0, return to sub-routine
00001478                           393  
00001478                           394  *
00001478                           395  * Display HEX Long: Display the hex from D0.L to screen
00001478                           396  *
00001478                           397  
00001478  4840                     398  DSPHXL  SWAP    D0              Swap first half to D0.W
0000147A  61D6                     399          BSR     DSPHXW          Display first half
0000147C  4840                     400          SWAP    D0              Swap lower half to D0.W
0000147E  61D2                     401          BSR     DSPHXW          Display lower half
00001480  4E75                     402          RTS                     Return to caller
00001482                           403  
00001482                           404  *
00001482                           405  * Display string: Displays string until NULL char
00001482                           406  * Input string at A1, output length of string at D1.B
00001482                           407  * Max length: 255
00001482                           408  *
00001482                           409          
00001482  48E7 E040                410  DSPSTR  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
00001486  243C 000000FF            411          MOVE.L  #255,D2         Set count to 255
0000148C  51CA 0006                412  DSPSTLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001490  6000 0012                413          BRA     DSPSTRT         If count is <= 0, branch to return
00001494  1019                     414          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
00001496  B03C 0000                415          CMP.B   #0,D0           Check if byte is NULL char
0000149A  6700 0008                416          BEQ     DSPSTRT         If byte is NULL char, branch to return
0000149E  6100 FF6E                417          BSR     DSPAX           Display ASCII
000014A2  60E8                     418          BRA     DSPSTLP         Loop back
000014A4  4482                     419  DSPSTRT NEG.L   D2              Negate count
000014A6  0682 000000FE            420          ADD.L   #254,D2         Add 254; effectively 255 - count - null byte
000014AC  4CDF 0003                421          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
000014B0  1202                     422          MOVE.B  D2,D1           Move length to D1
000014B2  4CDF 0204                423          MOVEM.L (SP)+,D2/A1     Restore D2 and A1
000014B6  4E75                     424          RTS                     Return to caller
000014B8                           425  
000014B8                           426  *
000014B8                           427  * Display An: Displays An or SP if n == 7
000014B8                           428  * Input n in D3
000014B8                           429  *
000014B8                           430  
000014B8  B63C 0007                431  DSPAn   CMP.B   #7,D3               Compare n to 7
000014BC  6700 0016                432          BEQ     DSPSP               If ==, branch to Display SP
000014C0  103C 0006                433          MOVE.B  #6,D0               Else, display character
000014C4  123C 0041                434          MOVE.B  #'A',D1             Read A
000014C8  4E4F                     435          TRAP    #15
000014CA  4280                     436          CLR.L   D0
000014CC  2003                     437          MOVE.L  D3,D0               Read reg from D3
000014CE  6100 FF6E                438          BSR     DSPHXB              Display as hex byte
000014D2  4E75                     439          RTS                         Return to caller
000014D4                           440  
000014D4  103C 0006                441  DSPSP   MOVE.B  #6,D0               Display character
000014D8  123C 0053                442          MOVE.B  #'S',D1             Read S
000014DC  4E4F                     443          TRAP    #15
000014DE  123C 0050                444          MOVE.B  #'P',D1             Read P
000014E2  4E4F                     445          TRAP    #15
000014E4  4E75                     446          RTS                         Return to caller
000014E6                           447  
000014E6                           448  *
000014E6                           449  * Brief Extension Word: Displays a brief extension word (without displacement)
000014E6                           450  * Input BEW to D0.B
000014E6                           451  * X|REG|S|SC|0 -> Xn.S * SC
000014E6                           452  * X (Index Register Type):
000014E6                           453  *   0 = Dn
000014E6                           454  *   1 = An
000014E6                           455  * S (Index Size):
000014E6                           456  *   0 = Sign-Extended Word
000014E6                           457  *   1 = Long Word
000014E6                           458  * SC (Scale):
000014E6                           459  *   00 = 1
000014E6                           460  *   01 = 2
000014E6                           461  *   10 = 4
000014E6                           462  *   11 = 8
000014E6                           463  *
000014E6                           464  
000014E6  48E7 F000                465  BEXTW   MOVEM.L D0-D3,-(SP)         Push D0-D3 to stack
000014EA  7470                     466          MOVE.L  #$70,D2             Extract REG at 01110000
000014EC  6100 FF08                467          BSR     EXTMSK              Get REG to D1
000014F0  1601                     468          MOVE.B  D1,D3               Move REG to D3
000014F2  243C 00000080            469          MOVE.L  #$80,D2             Extract X at 10000000
000014F8  6100 FEFC                470          BSR     EXTMSK              Get X to D1
000014FC  1401                     471          MOVE.B  D1,D2               Move MODE to D2
000014FE  6100 0112                472          BSR     DISPOP              Display Xn
00001502  7408                     473          MOVE.L  #8,D2               Extract S at 00001000
00001504  6100 FEF0                474          BSR     EXTMSK              Get S to D1
00001508  1601                     475          MOVE.B  D1,D3               Move S to D3
0000150A  7406                     476          MOVE.L  #6,D2               Extract SC at 00000110
0000150C  6100 FEE8                477          BSR     EXTMSK              Get SC to D1
00001510  C2FC 0004                478          MULU.W  #4,D1               Convert D1 to displacement
00001514  4EFB 1002                479          JMP     SCTBL(PC,D1.W)      Jump to SC mode
00001518  6000 000E                480  SCTBL   BRA     SC0                 00
0000151C  6000 0012                481          BRA     SC1                 01
00001520  6000 0016                482          BRA     SC2                 10
00001524  6000 001A                483          BRA     SC3                 11
00001528  143C 0001                484  SC0     MOVE.B  #1,D2               00 = 1
0000152C  6000 001A                485          BRA     SC4
00001530  143C 0002                486  SC1     MOVE.B  #2,D2               01 = 2
00001534  6000 0012                487          BRA     SC4
00001538  143C 0004                488  SC2     MOVE.B  #4,D2               10 = 4
0000153C  6000 000A                489          BRA     SC4
00001540  143C 0008                490  SC3     MOVE.B  #8,D2               11 = 8
00001544  6000 0002                491          BRA     SC4
00001548  103C 0006                492  SC4     MOVE.B  #6,D0               Display character
0000154C  123C 002E                493          MOVE.B  #'.',D1              Read . to D1
00001550  4E4F                     494          TRAP    #15
00001552  123C 004C                495          MOVE.B  #'L',D1             Read L to D1 as default
00001556  4A03                     496          TST.B   D3                  Test D3 for W
00001558  6604                     497          BNE     *+6                 If !=, skip next line
0000155A  123C 0057                498          MOVE.B  #'W',D1             Else, read W to D1
0000155E  4E4F                     499          TRAP    #15
00001560  123C 002A                500          MOVE.B  #'*',D1             Read *
00001564  4E4F                     501          TRAP    #15
00001566  103C 0003                502          MOVE.B  #3,D0               Display number
0000156A  1202                     503          MOVE.B  D2,D1               Read scale
0000156C  4E4F                     504          TRAP    #15
0000156E  4CDF 000F                505          MOVEM.L (SP)+,D0-D3         Restore D0-D3
00001572  4E75                     506          RTS                         Return to caller
00001574                           507  
00001574                           508  * Display displacement in D1.L
00001574  48E7 E000                509  DISPDIS MOVEM.L D0-D2,-(SP)         Push D0-D2 to stack
00001578  5481                     510          ADD.L   #2,D1               Add 2 to displacement to account for instruction
0000157A  2401                     511          MOVE.L  D1,D2               Copy displacement to D2
0000157C  103C 0006                512          MOVE.B  #6,D0               Display character
00001580  123C 002A                513          MOVE.B  #'*',D1             Read *
00001584  4E4F                     514          TRAP    #15
00001586  B4BC 00000000            515          CMP.L   #0,D2               Compare data to 0
0000158C  6F06                     516          BLE     *+8                 If < 0, skip next two lines
0000158E  123C 002B                517          MOVE.B  #'+',D1             Else, read +
00001592  4E4F                     518          TRAP    #15
00001594  103C 0003                519          MOVE.B  #3,D0               Display signed number
00001598  2202                     520          MOVE.L  D2,D1               Read data
0000159A  4E4F                     521          TRAP    #15
0000159C                           522          
0000159C                           523          * Begin comment annotation
0000159C  14FC 0024                524          MOVE.B  #'$',(A2)+          Read $
000015A0  2038 1000                525          MOVE.L  (GBUFF),D0          Move GBUFF address to D0
000015A4  5580                     526          SUB.L   #$2,D0              Subtract 2 to displacement to account for instruction
000015A6  D082                     527          ADD.L   D2,D0               Add displacement to address
000015A8  B0BC 0000FFFF            528          CMP.L   #$FFFF,D0           Compare address to greatest word address
000015AE  6E1C                     529          BGT.S   *+30                If >, skip to next test
000015B0  6100 FD6E                530          BSR     HEX2ASCII           Convert HEX word in D0 to ASCII long in D1
000015B4  4841                     531          SWAP    D1                  Swap LSB and MSB
000015B6  E159                     532          ROL.W   #8,D1               Move LSB to MSB
000015B8  14C1                     533          MOVE.B  D1,(A2)+            Read MSB
000015BA  E159                     534          ROL.W   #8,D1               Move MSB to LSB
000015BC  14C1                     535          MOVE.B  D1,(A2)+            Read LSB
000015BE  4841                     536          SWAP    D1                  Swap LSB abd MSB
000015C0  E159                     537          ROL.W   #8,D1               Move LSB to MSB
000015C2  14C1                     538          MOVE.B  D1,(A2)+            Read MSB
000015C4  E159                     539          ROL.W   #8,D1               Move MSB to LSB
000015C6  14C1                     540          MOVE.B  D1,(A2)+            Read LSB
000015C8  14BC 0001                541          MOVE.B  #1,(A2)             Read NULL char
000015CC  B0BC 0000FFFF            542          CMP.L   #$FFFF,D0           Compare again
000015D2  6F34                     543          BLE.S   *+54                If >, skip to NULL char
000015D4  4840                     544          SWAP    D0                  Swap LSB and MSB
000015D6  6100 FD48                545          BSR     HEX2ASCII           Convert HEX word in D0 to ASCII long in D1
000015DA  4841                     546          SWAP    D1                  Swap LSB and MSB
000015DC  E159                     547          ROL.W   #8,D1               Move LSB to MSB
000015DE  14C1                     548          MOVE.B  D1,(A2)+            Read MSB
000015E0  E159                     549          ROL.W   #8,D1               Move MSB to LSB
000015E2  14C1                     550          MOVE.B  D1,(A2)+            Read LSB
000015E4  4841                     551          SWAP    D1                  Swap LSB abd MSB
000015E6  E159                     552          ROL.W   #8,D1               Move LSB to MSB
000015E8  14C1                     553          MOVE.B  D1,(A2)+            Read MSB
000015EA  E159                     554          ROL.W   #8,D1               Move MSB to LSB
000015EC  14C1                     555          MOVE.B  D1,(A2)+            Read LSB
000015EE  4840                     556          SWAP    D0                  Swap LSB and MSB
000015F0  6100 FD2E                557          BSR     HEX2ASCII           Convert HEX word in D0 to ASCII long in D1
000015F4  4841                     558          SWAP    D1                  Swap LSB and MSB
000015F6  E159                     559          ROL.W   #8,D1               Move LSB to MSB
000015F8  14C1                     560          MOVE.B  D1,(A2)+            Read MSB
000015FA  E159                     561          ROL.W   #8,D1               Move MSB to LSB
000015FC  14C1                     562          MOVE.B  D1,(A2)+            Read LSB
000015FE  4841                     563          SWAP    D1                  Swap LSB abd MSB
00001600  E159                     564          ROL.W   #8,D1               Move LSB to MSB
00001602  14C1                     565          MOVE.B  D1,(A2)+            Read MSB
00001604  E159                     566          ROL.W   #8,D1               Move MSB to LSB
00001606  14C1                     567          MOVE.B  D1,(A2)+            Read LSB
00001608  14BC 0000                568          MOVE.B  #0,(A2)             Read NULL char
0000160C  4CDF 0007                569          MOVEM.L (SP)+,D0-D2         Restore D0-D2
00001610  4E75                     570          RTS                         Return to caller
00001612                           571  
00001612                           572  *
00001612                           573  * Display operand: Displays operand according to mode and register
00001612                           574  * Input mode in D2.B, input reg in D3.B
00001612                           575  *
00001612                           576  
00001612  48E7 FFFF                577  DISPOP  MOVEM.L D0-D7/A0-A7,-(SP)   Push all registers to stack
00001616  103C 0006                578          MOVE.B  #6,D0               Display character
0000161A  C4FC 0004                579          MULU.W  #4,D2
0000161E  4EFB 2002                580          JMP     DMDTBL(PC,D2.W)     Jump to mode
00001622  6000 0032                581  DMDTBL  BRA     DISPM0              Dn
00001626  6000 0040                582          BRA     DISPM1              An
0000162A  6000 0044                583          BRA     DISPM2              (An)
0000162E  6000 0058                584          BRA     DISPM3              (An)+
00001632  6000 0072                585          BRA     DISPM4              -(An)
00001636  6000 008C                586          BRA     DISPM5              (d,An)
0000163A  6000 00BC                587          BRA     DISPM6              (d,An,Xn)
0000163E  6000 0104                588          BRA     DISPM7              (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
00001642  6000 0224                589          BRA     DISPM8              3 BEARS CUSTOM
00001646  6000 0452                590          BRA     DISPM9              Special (111) next word
0000164A  6000 0462                591          BRA     DISPMA              3 BEARS CUSTOM (1000) next word
0000164E  6000 0472                592          BRA     DISPMB              3 BEARS CUSTOM (1000) previous word
00001652  6000 0482                593          BRA     DISPMC              3 BEARS CUSTOM (1000) previous long
00001656                           594  * Dn            0000 XXXX
00001656  123C 0044                595  DISPM0  MOVE.B  #'D',D1             Read D
0000165A  4E4F                     596          TRAP    #15
0000165C  4280                     597          CLR.L   D0
0000165E  1003                     598          MOVE.B  D3,D0               Read reg from D3
00001660  6100 FDDC                599          BSR     DSPHXB              Display as hex byte
00001664  6000 0484                600          BRA     DISPRT              Branch to return
00001668                           601  * An            0001 XXXX
00001668  6100 FE4E                602  DISPM1  BSR     DSPAn               Display An or SP        
0000166C  6000 047C                603          BRA     DISPRT              Branch to return
00001670                           604  * (An)          0010 XXXX
00001670  123C 0028                605  DISPM2  MOVE.B  #'(',D1             Read (
00001674  4E4F                     606          TRAP    #15
00001676  6100 FE40                607          BSR     DSPAn               Display An or SP
0000167A  103C 0006                608          MOVE.B  #6,D0               Display character
0000167E  123C 0029                609          MOVE.B  #')',D1             Read )
00001682  4E4F                     610          TRAP    #15
00001684  6000 0464                611          BRA     DISPRT              Branch to return
00001688                           612  * (An)+         0011 XXXX
00001688  123C 0028                613  DISPM3  MOVE.B  #'(',D1             Read (
0000168C  4E4F                     614          TRAP    #15
0000168E  6100 FE28                615          BSR     DSPAn               Display An or SP
00001692  103C 0006                616          MOVE.B  #6,D0               Display character
00001696  123C 0029                617          MOVE.B  #')',D1             Read )
0000169A  4E4F                     618          TRAP    #15
0000169C  123C 002B                619          MOVE.B  #'+',D1             Read +
000016A0  4E4F                     620          TRAP    #15
000016A2  6000 0446                621          BRA     DISPRT              Branch to return
000016A6                           622  * -(An)         0100 XXXX
000016A6  123C 002D                623  DISPM4  MOVE.B  #'-',D1             Read +
000016AA  4E4F                     624          TRAP    #15
000016AC  123C 0028                625          MOVE.B  #'(',D1             Read (
000016B0  4E4F                     626          TRAP    #15
000016B2  6100 FE04                627          BSR     DSPAn               Display An or SP
000016B6  103C 0006                628          MOVE.B  #6,D0               Display character
000016BA  123C 0029                629          MOVE.B  #')',D1             Read )
000016BE  4E4F                     630          TRAP    #15
000016C0  6000 0428                631          BRA     DISPRT              Branch to return
000016C4                           632  * (d16,An)      0101 XXXX
000016C4  123C 0028                633  DISPM5  MOVE.B  #'(',D1             Read (
000016C8  4E4F                     634          TRAP    #15
000016CA  103C 0003                635          MOVE.B  #3,D0               Display signed number
000016CE  2278 100E                636          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000016D2  3211                     637          MOVE.W  (A1),D1             Read word to D1
000016D4  48C1                     638          EXT.L   D1                  Extend word to long
000016D6  4E4F                     639          TRAP    #15
000016D8  54B8 100E                640          ADD.L   #2,(IOADDR)         Advance IO address by word
000016DC  103C 0006                641          MOVE.B  #6,D0               Display character
000016E0  123C 002C                642          MOVE.B  #',',D1             Read ,
000016E4  4E4F                     643          TRAP    #15
000016E6  6100 FDD0                644          BSR     DSPAn               Display An or SP
000016EA  103C 0006                645          MOVE.B  #6,D0               Display character
000016EE  123C 0029                646          MOVE.B  #')',D1             Read )
000016F2  4E4F                     647          TRAP    #15
000016F4  6000 03F4                648          BRA     DISPRT              Branch to return
000016F8                           649  * (d8,An,Xn)    0110 XXXX
000016F8  123C 0028                650  DISPM6  MOVE.B  #'(',D1             Read (
000016FC  4E4F                     651          TRAP    #15
000016FE  103C 0003                652          MOVE.B  #3,D0               Display signed number
00001702  2278 100E                653          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001706  11D9 115D                654          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
0000170A  1211                     655          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
0000170C  4881                     656          EXT.W   D1                  Extend byte to word
0000170E  48C1                     657          EXT.L   D1                  Extend word to long
00001710  4E4F                     658          TRAP    #15
00001712  103C 0006                659          MOVE.B  #6,D0               Display character
00001716  123C 002C                660          MOVE.B  #',',D1             Read ,
0000171A  4E4F                     661          TRAP    #15
0000171C  6100 FD9A                662          BSR     DSPAn               Display An or SP
00001720  103C 0006                663          MOVE.B  #6,D0               Display character
00001724  123C 002C                664          MOVE.B  #',',D1             Read ,
00001728  4E4F                     665          TRAP    #15
0000172A  1038 115D                666          MOVE.B  (DIS),D0            Read (DIS) to D0
0000172E  6100 FDB6                667          BSR     BEXTW               Display Brief Extension Word
00001732  54B8 100E                668          ADD.L   #2,(IOADDR)         Advance IO address by word
00001736  103C 0006                669          MOVE.B  #6,D0               Display character
0000173A  123C 0029                670          MOVE.B  #')',D1             Read )
0000173E  4E4F                     671          TRAP    #15
00001740  6000 03A8                672          BRA     DISPRT              Branch to return
00001744                           673  * (XXX).W/(XXX).L/(d16,PC)/(d8,PC,Xn)/#data
00001744  C6FC 0004                674  DISPM7  MULU.W  #4,D3
00001748  4EFB 3002                675          JMP     DRGTBL(PC,D3.W)     Jump to reg
0000174C  6000 0016                676  DRGTBL  BRA     DISPR0              (XXX).W
00001750  6000 002E                677          BRA     DISPR1              (XXX).L
00001754  6000 0046                678          BRA     DISPR2              (d,PC)
00001758  6000 007A                679          BRA     DISPR3              (d,PC,Xn)
0000175C  6000 00C6                680          BRA     DISPR4              #data
00001760  6000 00F4                681          BRA     DISPR5              CCR
00001764                           682  * (XXX.W)       0111 0000
00001764  123C 0024                683  DISPR0  MOVE.B  #'$',D1             Read $
00001768  4E4F                     684          TRAP    #15
0000176A  2278 100E                685          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000176E  4282                     686          CLR.L   D2
00001770  143C 0002                687          MOVE.B  #2,D2               Read word size to D2
00001774  6100 FCA2                688          BSR     DSPHXA              Display address
00001778  D5B8 100E                689          ADD.L   D2,(IOADDR)         Advance IO address by word
0000177C  6000 036C                690          BRA     DISPRT              Branch to return
00001780                           691  * (XXX.L)       0111 0001
00001780  123C 0024                692  DISPR1  MOVE.B  #'$',D1             Read $
00001784  4E4F                     693          TRAP    #15
00001786  2278 100E                694          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000178A  4282                     695          CLR.L   D2
0000178C  143C 0004                696          MOVE.B  #4,D2               Read long size to D2
00001790  6100 FC86                697          BSR     DSPHXA              Display address
00001794  D5B8 100E                698          ADD.L   D2,(IOADDR)         Advance IO address by long
00001798  6000 0350                699          BRA     DISPRT              Branch to return
0000179C                           700  * (d16,PC)      0111 0010
0000179C  123C 0028                701  DISPR2  MOVE.B  #'(',D1             Read (
000017A0  4E4F                     702          TRAP    #15
000017A2  103C 0003                703          MOVE.B  #3,D0               Display signed number
000017A6  2278 100E                704          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000017AA  3211                     705          MOVE.W  (A1),D1             Read word to D1
000017AC  48C1                     706          EXT.L   D1                  Extend word to long
000017AE  4E4F                     707          TRAP    #15
000017B0  54B8 100E                708          ADD.L   #2,(IOADDR)         Advance IO address by word
000017B4  103C 0006                709          MOVE.B  #6,D0               Display character
000017B8  123C 002C                710          MOVE.B  #',',D1             Read ,
000017BC  4E4F                     711          TRAP    #15
000017BE  123C 0050                712          MOVE.B  #'P',D1             Read P
000017C2  4E4F                     713          TRAP    #15
000017C4  123C 0043                714          MOVE.B  #'C',D1             Read C
000017C8  4E4F                     715          TRAP    #15
000017CA  123C 0029                716          MOVE.B  #')',D1             Read )
000017CE  4E4F                     717          TRAP    #15
000017D0  6000 0318                718          BRA     DISPRT              
000017D4                           719  * (d8,PC,Xn)    0111 0011
000017D4  123C 0028                720  DISPR3  MOVE.B  #'(',D1             Read (
000017D8  4E4F                     721          TRAP    #15
000017DA  103C 0003                722          MOVE.B  #3,D0               Display signed number
000017DE  2278 100E                723          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000017E2  11D9 115D                724          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
000017E6  1211                     725          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
000017E8  4881                     726          EXT.W   D1                  Extend byte to word
000017EA  48C1                     727          EXT.L   D1                  Extend word to long
000017EC  4E4F                     728          TRAP    #15
000017EE  103C 0006                729          MOVE.B  #6,D0               Display character
000017F2  123C 002C                730          MOVE.B  #',',D1             Read ,
000017F6  4E4F                     731          TRAP    #15
000017F8  123C 0050                732          MOVE.B  #'P',D1             Read P
000017FC  4E4F                     733          TRAP    #15
000017FE  123C 0043                734          MOVE.B   #'C',D1            Read C
00001802  4E4F                     735          TRAP    #15
00001804  123C 002C                736          MOVE.B  #',',D1             Read ,
00001808  4E4F                     737          TRAP    #15
0000180A  1038 115D                738          MOVE.B  (DIS),D0            Read (DIS) to D0
0000180E  6100 FCD6                739          BSR     BEXTW               Display Brief Extension Word
00001812  54B8 100E                740          ADD.L   #2,(IOADDR)         Advance IO address by word
00001816  103C 0006                741          MOVE.B  #6,D0               Display character
0000181A  123C 0029                742          MOVE.B  #')',D1             Read )
0000181E  4E4F                     743          TRAP    #15
00001820  6000 02C8                744          BRA     DISPRT              Branch to return
00001824                           745  * #<data>       0111 0100
00001824  123C 0023                746  DISPR4  MOVE.B  #'#',D1             Read #
00001828  4E4F                     747          TRAP    #15
0000182A  123C 0024                748          MOVE.B  #'$',D1             Read $
0000182E  4E4F                     749          TRAP    #15
00001830  2278 100E                750          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001834  4282                     751          CLR.L   D2
00001836  1438 100C                752          MOVE.B  (IOSIZE),D2         Read instruction size to D2
0000183A  B43C 0000                753          CMP.B   #0,D2               Test if size is byte
0000183E  6604                     754          BNE     *+6                 If !=, skip next line
00001840  143C 0001                755          MOVE.B  #1,D2               If ==, change byte to word
00001844  C4FC 0002                756          MULU.W  #2,D2               Translate size to value
00001848  6100 FBCE                757          BSR     DSPHXA              Display address
0000184C  D3C2                     758          ADD.L   D2,A1               Advance A1 by instruction size
0000184E  21C9 100E                759          MOVE.L  A1,(IOADDR)         Move A1 to IOADDR
00001852  6000 0296                760          BRA     DISPRT              Branch to return
00001856                           761  * CCR
00001856  123C 0043                762  DISPR5  MOVE.B  #'C',D1             Read C
0000185A  4E4F                     763          TRAP    #15
0000185C  4E4F                     764          TRAP    #15
0000185E  123C 0052                765          MOVE.B  #'R',D1             Read R
00001862  4E4F                     766          TRAP    #15
00001864  6000 0284                767          BRA     DISPRT              Branch to return
00001868                           768  * 3 BEARS CUSTOM MODE
00001868                           769  * Custom sizes:
00001868                           770  *   Q = Quick data
00001868  C6FC 0004                771  DISPM8  MULU.W  #4,D3
0000186C  4EFB 3002                772          JMP     D3BTBL(PC,D3.W)     Jump to reg
00001870  6000 0026                773  D3BTBL  BRA     DISPC0              #<1-8>.Q
00001874  6000 004C                774          BRA     DISPC1              #<data>.Q
00001878  6000 0068                775          BRA     DISPC2              (DIS).Q
0000187C  6000 0084                776          BRA     DISPC3              (DIS).B
00001880  6000 0096                777          BRA     DISPC4              (DIS).W
00001884  6000 00A6                778          BRA     DISPC5              (DIS).L
00001888  6000 00B4                779          BRA     DISPC6              (RLM).L
0000188C  6000 013E                780          BRA     DISPC7              (MLR).L
00001890  6000 01CC                781          BRA     DISPC8              #<bit num>.B
00001894  6000 01E0                782          BRA     DISPC9              #<0-7>.Q
00001898                           783  
00001898                           784  * #<1-8>.Q     1000 0000
00001898  123C 0023                785  DISPC0  MOVE.B  #'#',D1             Read #
0000189C  4E4F                     786          TRAP    #15
0000189E  4280                     787          CLR.L   D0
000018A0  4281                     788          CLR.L   D1
000018A2  2278 100E                789          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000018A6  3021                     790          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
000018A8  243C 00000E00            791          MOVE.L  #$0E00,D2           Extract data at 000011100000000
000018AE  6100 FB46                792          BSR     EXTMSK              Get the data to D1
000018B2  4A41                     793          TST     D1                  Compare data to 0
000018B4  6602                     794          BNE     *+4                 If !=, skip the next line
000018B6  7208                     795          MOVE.L  #8,D1               Else, change 0 to 8
000018B8  103C 0003                796          MOVE.B  #3,D0               Read number
000018BC  4E4F                     797          TRAP    #15
000018BE  6000 022A                798          BRA     DISPRT              Branch to return
000018C2                           799  * #<data>.Q     1000 0001
000018C2  123C 0023                800  DISPC1  MOVE.B  #'#',D1             Read #
000018C6  4E4F                     801          TRAP    #15
000018C8  4280                     802          CLR.L   D0
000018CA  4281                     803          CLR.L   D1
000018CC  2278 100E                804          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000018D0  3021                     805          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
000018D2  740F                     806          MOVE.L  #$000F,D2           Extract data at 0000000000001111
000018D4  6100 FB20                807          BSR     EXTMSK              Get the data to D1
000018D8  103C 0003                808          MOVE.B  #3,D0               Read number
000018DC  4E4F                     809          TRAP    #15
000018DE  6000 020A                810          BRA     DISPRT              Branch to return
000018E2                           811  * (DIS).Q       1000 0010
000018E2                           812  * "1000 BRA -7 *Branch back 7 bytes
000018E2                           813  *  is acceptable, but:
000018E2                           814  *  1000 BRA 993 * Branch to address 993
000018E2                           815  *  is better."
000018E2                           816  *  3 Bears believes:
000018E2                           817  *  1000 BRA *-7 ($993)
000018E2                           818  *  is BEST.
000018E2  4280                     819  DISPC2  CLR.L   D0
000018E4  4281                     820          CLR.L   D1
000018E6  2278 100E                821          MOVEA.L IOADDR,A1           Point A1 to the instruction address
000018EA  3021                     822          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
000018EC  243C 000000FF            823          MOVE.L  #$00FF,D2           Extract byte displacement at 0000000011111111
000018F2  6100 FB02                824          BSR     EXTMSK              Get the data to D1
000018F6  4881                     825          EXT.W   D1                  Extend byte to word
000018F8  48C1                     826          EXT.L   D1                  Extend word to long
000018FA  6100 FC78                827          BSR     DISPDIS             Display displacement
000018FE  6000 01EA                828          BRA     DISPRT              Branch to return
00001902                           829          
00001902                           830  * (DIS).B       1000 0011
00001902  4280                     831  DISPC3  CLR.L   D0
00001904  4281                     832          CLR.L   D1
00001906  2278 100E                833          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000190A  3211                     834          MOVE.W  (A1),D1             Get displacement to D1
0000190C  4881                     835          EXT.W   D1                  Extend byte to word
0000190E  48C1                     836          EXT.L   D1                  Extend word to long
00001910  6100 FC62                837          BSR     DISPDIS             Display displacement
00001914  6000 01D4                838          BRA     DISPRT              Branch to return
00001918                           839  * (DIS).W       1000 0100
00001918  4280                     840  DISPC4  CLR.L   D0
0000191A  4281                     841          CLR.L   D1
0000191C  2278 100E                842          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001920  3211                     843          MOVE.W  (A1),D1             Get displacement to D1
00001922  48C1                     844          EXT.L   D1                  Extend word to long
00001924  6100 FC4E                845          BSR     DISPDIS             Display displacement
00001928  6000 01C0                846          BRA     DISPRT              Branch to return
0000192C                           847  * (DIS).L       1000 0101
0000192C  4280                     848  DISPC5  CLR.L   D0
0000192E  4281                     849          CLR.L   D1
00001930  2278 100E                850          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001934  2211                     851          MOVE.L  (A1),D1             Get displacement to D1
00001936  6100 FC3C                852          BSR     DISPDIS             Display displacement
0000193A  6000 01AE                853          BRA     DISPRT              Branch to return
0000193E                           854  * (RLM).W       1000 0110
0000193E  2278 100E                855  DISPC6  MOVEA.L IOADDR,A1   Point A1 to the instruction address
00001942  4282                     856          CLR.L   D2
00001944  3411                     857          MOVE.W  (A1),D2     Get register list mask to D2
00001946  7600                     858          MOVE.L  #0,D3       Count
00001948  1A3C 0044                859          MOVE.B  #'D',D5     D/A
0000194C  1C3C 0000                860          MOVE.B  #$00,D6     / or - separator (set to null for first 1)
00001950  207C 000019BC            861          MOVE.L  #RLMNXT,A0  Next instruction
00001956  0702                     862  RLMLP   BTST.L  D3,D2       Check bit at count for 0
00001958  6700 0058                863          BEQ     RLMADV      If bit was 0, branch to LPADV
0000195C  103C 0006                864          MOVE.B  #6,D0       Else, display character
00001960  1206                     865          MOVE.B  D6,D1       Read separator
00001962  1C3C 002F                866          MOVE.B  #'/',D6     Set next default separator to /
00001966  4E4F                     867          TRAP    #15
00001968  1205                     868          MOVE.B  D5,D1       Read A/D
0000196A  4E4F                     869          TRAP    #15
0000196C  103C 0003                870          MOVE.B  #3,D0       Display number
00001970  2203                     871          MOVE.L  D3,D1       Read count
00001972  4E4F                     872          TRAP    #15
00001974  2803                     873          MOVE.L  D3,D4       Move bit location to D4
00001976  B63C 0007                874  RLMINC  CMP.B   #7,D3       Compare count to 7
0000197A  6708                     875          BEQ     *+10        If ==, branch to decrement count
0000197C  5203                     876          ADD.B   #1,D3       Else, increment count
0000197E  0702                     877          BTST.L  D3,D2       Check next bit at count for 0
00001980  66F4                     878          BNE     RLMINC      If bit was not 0, keep incrementing
00001982  5303                     879          SUB.B   #1,D3       Decrement count
00001984  4404                     880          NEG.B   D4          Negate bit location
00001986  D803                     881          ADD.B   D3,D4       Add count to location; effectively, count - location = length
00001988  B83C 0001                882          CMP.B   #1,D4       Compare length to 1
0000198C  6F04                     883          BLE     *+6         If <=, skip the next line
0000198E  1C3C 002D                884          MOVE.B  #'-',D6     Else, set separator to -
00001992  B83C 0000                885          CMP.B   #0,D4       Compare length to 0
00001996  6700 001A                886          BEQ     RLMADV      If ==, branch to instruction
0000199A  103C 0006                887          MOVE.B  #6,D0       Else, display character
0000199E  1206                     888          MOVE.B  D6,D1       Read separator
000019A0  1C3C 002F                889          MOVE.B  #'/',D6     Set next default separator to /
000019A4  4E4F                     890          TRAP    #15
000019A6  1205                     891          MOVE.B  D5,D1       Read A/D
000019A8  4E4F                     892          TRAP    #15
000019AA  103C 0003                893          MOVE.B  #3,D0       Display number
000019AE  2203                     894          MOVE.L  D3,D1       Read count
000019B0  4E4F                     895          TRAP    #15
000019B2  5203                     896  RLMADV  ADD.B   #1,D3       Increment count
000019B4  B63C 0007                897          CMP.B   #7,D3       Compare count to 7
000019B8  6F9C                     898          BLE     RLMLP       If <=, branch back to loop
000019BA  4ED0                     899          JMP     (A0)        Else, jump to address in A0
000019BC  E15A                     900  RLMNXT  ROL.W   #8,D2       Move A bits to LSB
000019BE  7600                     901          MOVE.L  #0,D3       Count
000019C0  1A3C 0041                902          MOVE.B  #'A',D5     D/A
000019C4  207C 00001AEA            903          MOVE.L  #DISPRT,A0  Next instruction
000019CA  608A                     904          BRA     RLMLP       Display A registers
000019CC                           905  * (MLR).W       1000 0110
000019CC  2278 100E                906  DISPC7  MOVEA.L IOADDR,A1   Point A1 to the instruction address
000019D0  4282                     907          CLR.L   D2
000019D2  3411                     908          MOVE.W  (A1),D2     Get register list mask to D2
000019D4  E15A                     909          ROL.W   #8,D2       Move D bits to LSB
000019D6  7607                     910          MOVE.L  #7,D3       Count
000019D8  1A3C 0044                911          MOVE.B  #'D',D5     D/A
000019DC  1C3C 0000                912          MOVE.B  #$00,D6     / or - separator (set to null for first 1)
000019E0  207C 00001A4E            913          MOVE.L  #MLRNXT,A0  Next instruction
000019E6  0702                     914  MLRLP   BTST.L  D3,D2       Check bit at count for 0
000019E8  6700 005A                915          BEQ     MLRADV      If bit was 0, branch to LPADV
000019EC  103C 0006                916          MOVE.B  #6,D0       Else, display character
000019F0  1206                     917          MOVE.B  D6,D1       Read separator
000019F2  1C3C 002F                918          MOVE.B  #'/',D6     Set next default separator to /
000019F6  4E4F                     919          TRAP    #15
000019F8  1205                     920          MOVE.B  D5,D1       Read A/D
000019FA  4E4F                     921          TRAP    #15
000019FC  103C 0003                922          MOVE.B  #3,D0       Display number
00001A00  7207                     923          MOVE.L  #7,D1       Read 7
00001A02  9203                     924          SUB.B   D3,D1       Subtract count
00001A04  4E4F                     925          TRAP    #15
00001A06  2803                     926          MOVE.L  D3,D4       Move bit location to D4
00001A08  B63C 0000                927  MLRDEC  CMP.B   #0,D3       Compare count to 0
00001A0C  6708                     928          BEQ     *+10        If ==, branch to decrement count
00001A0E  5303                     929          SUB.B   #1,D3       Else, decrement count
00001A10  0702                     930          BTST.L  D3,D2       Check next bit at count for 0
00001A12  66F4                     931          BNE     MLRDEC      If bit was not 0, keep decrementing
00001A14  5203                     932          ADD.B   #1,D3       Increment count
00001A16  9803                     933          SUB.B   D3,D4       Location - count = length
00001A18  B83C 0001                934          CMP.B   #1,D4       Compare length to 1
00001A1C  6F04                     935          BLE     *+6         If <=, skip the next line
00001A1E  1C3C 002D                936          MOVE.B  #'-',D6     Else, set separator to -
00001A22  B83C 0000                937          CMP.B   #0,D4       Compare length to 0
00001A26  6700 001C                938          BEQ     MLRADV      If ==, branch to instruction
00001A2A  103C 0006                939          MOVE.B  #6,D0       Else, display character
00001A2E  1206                     940          MOVE.B  D6,D1       Read separator
00001A30  1C3C 002F                941          MOVE.B  #'/',D6     Set next default separator to /
00001A34  4E4F                     942          TRAP    #15
00001A36  1205                     943          MOVE.B  D5,D1       Read A/D
00001A38  4E4F                     944          TRAP    #15
00001A3A  103C 0003                945          MOVE.B  #3,D0       Display number
00001A3E  7207                     946          MOVE.L  #7,D1       Read 7
00001A40  9203                     947          SUB.B   D3,D1       Subtract count
00001A42  4E4F                     948          TRAP    #15
00001A44  5303                     949  MLRADV  SUB.B   #1,D3       Decrement count
00001A46  B63C 0000                950          CMP.B   #0,D3       Compare count to 0
00001A4A  6C9A                     951          BGE     MLRLP       If >=, branch back to loop
00001A4C  4ED0                     952          JMP     (A0)        Else, jump to address in A0
00001A4E  E15A                     953  MLRNXT  ROL.W   #8,D2       Move A bits to LSB
00001A50  7607                     954          MOVE.L  #7,D3       Count
00001A52  1A3C 0041                955          MOVE.B  #'A',D5     D/A
00001A56  207C 00001AEA            956          MOVE.L  #DISPRT,A0  Next instruction
00001A5C  6088                     957          BRA     MLRLP       Display A registers
00001A5E                           958  * #<bit num>.B  1000 0111
00001A5E  123C 0023                959  DISPC8  MOVE.B  #'#',D1             Read #
00001A62  4E4F                     960          TRAP    #15
00001A64  4281                     961          CLR.L   D1
00001A66  2278 100E                962          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001A6A  3211                     963          MOVE.W  (A1),D1             Read bit number to D1
00001A6C  103C 0003                964          MOVE.B  #3,D0               Display number
00001A70  4E4F                     965          TRAP    #15
00001A72  6000 0076                966          BRA     DISPRT              Branch to return
00001A76                           967  * #<0-7>.Q      1000 1000
00001A76  123C 0023                968  DISPC9  MOVE.B  #'#',D1             Read #
00001A7A  4E4F                     969          TRAP    #15
00001A7C  4280                     970          CLR.L   D0
00001A7E  4281                     971          CLR.L   D1
00001A80  2278 100E                972          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001A84  3021                     973          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
00001A86  243C 00000E00            974          MOVE.L  #$0E00,D2           Extract data at 000011100000000
00001A8C  6100 F968                975          BSR     EXTMSK              Get the data to D1
00001A90  103C 0003                976          MOVE.B  #3,D0               Read number
00001A94  4E4F                     977          TRAP    #15
00001A96  6000 0052                978          BRA     DISPRT              Branch to return
00001A9A                           979  * Special-- next word: The mode was 111, but the value is located in the next word
00001A9A  54B8 100E                980  DISPM9  ADD.L   #2,IOADDR           Advance IOADDR by word
00001A9E  143C 0007                981          MOVE.B  #%111,D2            Set mode to 111
00001AA2  6100 FB6E                982          BSR     DISPOP              Display the special mode
00001AA6  55B8 100E                983          SUB.L   #2,IOADDR           Re-align IOADDR
00001AAA  6000 003E                984          BRA     DISPRT              Branch to return
00001AAE                           985  * 3B Special-- next word: The mode was 1000, but the value is located in the next word
00001AAE  54B8 100E                986  DISPMA  ADD.L   #2,IOADDR           Increment IOADDR by word
00001AB2  143C 0008                987          MOVE.B  #%1000,D2           Set mode to 1000
00001AB6  6100 FB5A                988          BSR     DISPOP              Display the special mode
00001ABA  55B8 100E                989          SUB.L   #2,IOADDR           Re-align IOADDR
00001ABE  6000 002A                990          BRA     DISPRT              Branch to return
00001AC2                           991  * 3B Special-- previous word: The mode was 1000, but the value is located in the previous word
00001AC2  55B8 100E                992  DISPMB  SUB.L   #2,IOADDR           Decrement IOADDR by word
00001AC6  143C 0008                993          MOVE.B  #%1000,D2           Set mode to 1000
00001ACA  6100 FB46                994          BSR     DISPOP              Display the special mode
00001ACE  54B8 100E                995          ADD.L   #2,IOADDR           Re-align IOADDR
00001AD2  6000 0016                996          BRA     DISPRT              Branch to return
00001AD6                           997  * 3B Special-- previous long: The mode was 1000, but the value is located in the previous long
00001AD6  59B8 100E                998  DISPMC  SUB.L   #4,IOADDR           Decrement IOADDR by long
00001ADA  143C 0008                999          MOVE.B  #%1000,D2           Set mode to 1000
00001ADE  6100 FB32               1000          BSR     DISPOP              Display the special mode
00001AE2  54B8 100E               1001          ADD.L   #2,IOADDR           Re-align IOADDR
00001AE6  6000 0002               1002          BRA     DISPRT              Branch to return
00001AEA                          1003          
00001AEA  4CDF FFFF               1004  DISPRT  MOVEM.L (SP)+,D0-D7/A0-A7   Restore all registers
00001AEE  4E75                    1005          RTS                         Return to caller
00001AF0                          1006          
00001AF0                          1007  
00001AF0                          1008  * Display instruction: PRINT sub-routine
00001AF0  103C 000B               1009  DISPINS MOVE.B  #11,D0              Position cursor col/row
00001AF4  323C 1E00               1010          MOVE.W  #$1E00,D1           Set column
00001AF8  1238 1012               1011          MOVE.B  IOLC,D1             Set row to line counter
00001AFC  5201                    1012          ADD.B   #1,D1               Increase row by 1
00001AFE  4E4F                    1013          TRAP    #15
00001B00  43F8 1028               1014          LEA     OPNAME,A1           Read OP-code
00001B04  4280                    1015          CLR.L   D0                  Clear D0 for offset
00001B06  3038 1008               1016          MOVE.W  (IOOPCD),D0         Get offset
00001B0A  D3C0                    1017          ADD.L   D0,A1               Add offset
00001B0C  6100 F974               1018          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001B10  43F8 114C               1019          LEA     IOOPSZ,A1           Read OP code size
00001B14  7003                    1020          MOVE.L  #$03,D0             Set size to 3
00001B16  0C38 00FF 100C          1021          CMP.B   #$FF,(IOSIZE)       Test if OP size exists
00001B1C  6704                    1022          BEQ     *+6                 If OP size doesn't exist, skip the next line
00001B1E  1038 100C               1023          MOVE.B  (IOSIZE),D0         If OP size exists, move it to D0
00001B22  C0FC 0003               1024          MULU.W  #$3,D0              Multiply size by 3 for correct offset
00001B26  D3C0                    1025          ADD.L   D0,A1               Add offset
00001B28  6100 F958               1026          BSR     DSPSTR              Display string until NULL char and get length in D1.B
00001B2C  D401                    1027          ADD.B   D1,D2               Add length to space offset
00001B2E  103C 000B               1028          MOVE.B  #11,D0              Position cursor col/row
00001B32  323C 2600               1029          MOVE.W  #$2600,D1           Set column
00001B36  1238 1012               1030          MOVE.B  IOLC,D1             Set row to line counter
00001B3A  5201                    1031          ADD.B   #1,D1               Increase row by 1
00001B3C  4E4F                    1032          TRAP    #15
00001B3E  4E75                    1033          RTS                         Return to PRINT
00001B40                          1034  
00001B40                          1035  * Display source: PRINT sub-routine
00001B40  4242                    1036  DISPSRC CLR.W   D2                  Clear mode offset so value <= 7
00001B42  4243                    1037          CLR.W   D3                  Clear reg offset so value <= 7
00001B44  1438 115A               1038          MOVE.B  (SMD),D2            Read source mode to D2
00001B48  B43C 00FF               1039          CMP.B   #$FF,D2             Test if it exists
00001B4C  6700 F73E               1040          BEQ     FLAGCL              If it does not exist, branch to clear flag
00001B50  1638 115B               1041          MOVE.B  (SRG),D3            Else, read source reg to D3
00001B54  B63C 00FF               1042          CMP.B   #$FF,D3             Test if it exists
00001B58  6700 F732               1043          BEQ     FLAGCL              If it does not exist, branch to clear flag
00001B5C  6000 F728               1044          BRA     FLAGST              Else, branch to set flag
00001B60                          1045  
00001B60                          1046  * Display destination: PRINT sub-routine
00001B60  4242                    1047  DISPDST CLR.W   D2                  Reset mode offset
00001B62  4243                    1048          CLR.W   D3                  Reset register offset
00001B64  1438 1158               1049          MOVE.B  (DMD),D2            Read dest mode to D2
00001B68  B43C 00FF               1050          CMP.B   #$FF,D2             Test if it exists
00001B6C  6700 F71E               1051          BEQ     FLAGCL              If it does not exist, branch to clear flag
00001B70  1638 1159               1052          MOVE.B  (DRG),D3            Else, read dest reg to D3
00001B74  B63C 00FF               1053          CMP.B   #$FF,D3             Test if it exists
00001B78  6700 F712               1054          BEQ     FLAGCL              If it does not exist, branch to clear flg
00001B7C  6000 F708               1055          BRA     FLAGST              Else, branch to set flag
00001B80                          1056  
00001B80                          1057  * Display address: PRINT sub-routine
00001B80  103C 000B               1058  DISPADR MOVE.B  #11,D0              Position cursor col/row
00001B84  323C 0000               1059          MOVE.W  #$0000,D1           First column
00001B88  1238 1012               1060          MOVE.B  IOLC,D1             Set row to line counter
00001B8C  5201                    1061          ADD.B   #1,D1               Increase row by 1
00001B8E  4E4F                    1062          TRAP    #15
00001B90  2038 100E               1063          MOVE.L  (IOADDR),D0         Read memory location
00001B94  6100 F8E2               1064          BSR     DSPHXL              Display as hex long
00001B98  4E75                    1065          RTS                         Return to PRINT
00001B9A                          1066  
00001B9A                          1067  * Display raw data: PRINT sub-routine
00001B9A  48E7 E040               1068  DISPRAW MOVEM.L D0-D2/A1,-(SP)
00001B9E  103C 000B               1069          MOVE.B  #11,D0              Position cursor col/row
00001BA2  323C 0900               1070          MOVE.W  #$0900,D1           Set column
00001BA6  1238 1012               1071          MOVE.B  IOLC,D1             Set row to line counter
00001BAA  5201                    1072          ADD.B   #1,D1               Increase row by 1
00001BAC  4E4F                    1073          TRAP    #15
00001BAE  2438 1000               1074          MOVE.L  (GBUFF),D2          Move GBUFF to D2
00001BB2  94B8 100E               1075          SUB.L   (IOADDR),D2         Subtract IOADDR from GBUFF
00001BB6  5482                    1076          ADD.L   #2,D2               Add instruction length
00001BB8  2278 100E               1077          MOVEA.L IOADDR,A1           Point A1 to IOADDR
00001BBC  6100 F85A               1078          BSR     DSPHXA              Display address with D2 length
00001BC0  4CDF 0207               1079          MOVEM.L (SP)+,D0-D2/A1
00001BC4  4E75                    1080          RTS                         Return to PRINT
00001BC6                          1081  
00001BC6                          1082  * Display bad code: PRINT sub-routine
00001BC6  43F8 1028               1083  DISPBD  LEA     OPNAME,A1           Read OP-code
00001BCA  4280                    1084          CLR.L   D0                  Clear offset
00001BCC  3038 100A               1085          MOVE.W  (IOBDCD),D0         Get offset
00001BD0  D3C0                    1086          ADD.L   D0,A1               Add offset
00001BD2                          1087          * Begin comment annotation
00001BD2  14D9                    1088          MOVE.B  (A1)+,(A2)+         Read char
00001BD4  0C11 0000               1089          CMP.B   #0,(A1)             Compare to NULL char
00001BD8  66F8                    1090          BNE.S   *-6                 If !=, keep reading
00001BDA  14FC 003F               1091          MOVE.B  #'?',(A2)+          Read ?
00001BDE  14BC 0000               1092          MOVE.B  #0,(A2)             Read NULL char
00001BE2  31FC 00FF 100A          1093          MOVE.W  #$FF,(IOBDCD)       Reset BAD OPCODE
00001BE8  4E75                    1094          RTS                         Return to PRINT
00001BEA                          1095  
00001BEA                          1096  * Display annotations: PRINT sub-routine
00001BEA  103C 000B               1097  DISPANO MOVE.B  #11,D0              Position cursor col/row
00001BEE  323C 3C00               1098          MOVE.W  #$3C00,D1           Annotation column
00001BF2  1238 1012               1099          MOVE.B  IOLC,D1             Set row to line counter
00001BF6  5201                    1100          ADD.B   #1,D1               Increase row by 1
00001BF8  4E4F                    1101          TRAP    #15
00001BFA  224A                    1102          MOVE.L  A2,A1               Move comment location to A1
00001BFC  6100 F884               1103          BSR     DSPSTR              Display until NULL char
00001C00  247C 00001014           1104          MOVE.L  #COMMENT,A2         Reset comment location
00001C06  14BC 0000               1105          MOVE.B  #0,(A2)             Set NULL char
00001C0A  4E75                    1106          RTS                         Return to PRINT
00001C0C                          1107  
00001C0C                          1108  * Test Bad: Tests if BAD OPCODE exists, and is not BAD
00001C0C                          1109  * Prevents screen from displaying DATA (DATA?) when NO instruction matched
00001C0C  0C78 00FF 100A          1110  TSTBAD  CMP.W   #$FF,IOBDCD         Check if BAD OPCODE exists
00001C12  6700 F678               1111          BEQ     FLAGCL              If it does not exists, branch to clear flag
00001C16  0C78 007B 100A          1112          CMP.W   #$7B,IOBDCD         Else, check if BAD OPCODE is bad
00001C1C  6700 F66E               1113          BEQ     FLAGCL              If ==, branch to clear flag
00001C20  6000 F664               1114          BRA     FLAGST              Else, branch to set flag
00001C24                          1115  
00001C24                          1116  * Bad: Where naughty instructions are sent to be punished
00001C24  31F8 1008 100A          1117  BRBAD   MOVE.W  (IOOPCD),(IOBDCD)   Move OPCODE to BAD OPCODE
00001C2A  31FC 003F 1008          1118          MOVE.W  #$03F,(IOOPCD)      Set OPCODE to BAD
00001C30  0C38 0004 1013          1119          CMP.B   #4,IOBC             Compare bad counter to 4
00001C36  6D00 0006               1120          BLT     BADADV              If < 4, branch to advance bad counter
00001C3A  4238 1013               1121          CLR.B   (IOBC)              Else, set counter to 0
00001C3E  5238 1013               1122  BADADV  ADD.B   #1,IOBC             Increment bad counter
00001C42                          1123          * Clear bad data
00001C42  11FC 00FF 115A          1124          MOVE.B  #$FF,(SMD)
00001C48  11FC 00FF 115B          1125          MOVE.B  #$FF,(SRG)
00001C4E  11FC 00FF 1158          1126          MOVE.B  #$FF,(DMD)
00001C54  11FC 00FF 1159          1127          MOVE.B  #$FF,(DRG)
00001C5A  11FC 00FF 100C          1128          MOVE.B  #$FF,(IOSIZE)
00001C60  6000 0002               1129          BRA     PRINT               Branch to PRINT
00001C64                          1130  
00001C64                          1131  * PRINT: WHERE ALL OF THE MAGIC HAPPENS!!! :D
00001C64  45F8 1014               1132  PRINT   LEA     COMMENT,A2          Point A2 to comment annotations
00001C68  0C78 00FF 1008          1133          CMP.W   #$FF,(IOOPCD)       Test if OP code exists
00001C6E  67B4                    1134          BEQ     BRBAD               If it does not, display BAD
00001C70  4284                    1135          CLR.L   D4                  Set source to false
00001C72  0C78 003F 1008          1136          CMP.W   #$03F,(IOOPCD)      Compare OP code to BAD
00001C78  6600 005E               1137          BNE     NOTBAD              If !=, branch to NOTBAD
00001C7C  0C38 0001 1013          1138          CMP.B   #1,IOBC             Else, compare bad counter to 1
00001C82  6E00 0022               1139          BGT     DISPDAT             If > 1, branch to display raw data
00001C86  11FC 0001 1013          1140  NEWBAD  MOVE.B  #1,(IOBC)           Set bad counter to 1
00001C8C  6100 FEF2               1141          BSR     DISPADR             Display address
00001C90  6100 FF08               1142          BSR     DISPRAW             Display raw data
00001C94  6100 FE5A               1143          BSR     DISPINS             Display instruction (DATA)
00001C98  6100 FF72               1144          BSR     TSTBAD              Test if BAD OP code exists
00001C9C  6604                    1145          BNE     *+6                 If it doesn't exist, skip the next line
00001C9E  6100 FF26               1146          BSR     DISPBD              Else, branch to DISPBD and reset IOBDCD
00001CA2  5238 1012               1147          ADD.B   #1,IOLC             Increment line counter to counteract DISPDAT
00001CA6  6100 FF64               1148  DISPDAT BSR     TSTBAD              Test if BAD OP code exists
00001CAA  67DA                    1149          BEQ     NEWBAD              If it exists, branch to NEWBAD to start a new line
00001CAC  103C 000B               1150          MOVE.B  #11,D0              Else, position cursor col/row
00001CB0  1238 1013               1151          MOVE.B  (IOBC),D1           Move bad counter to D1
00001CB4  5301                    1152          SUB.B   #1,D1               Decrement by 1
00001CB6  C2FC 0004               1153          MULU.W  #4,D1               Multiply by word space
00001CBA  0641 0009               1154          ADD.W   #0009,D1            Add column
00001CBE  E149                    1155          LSL.W   #8,D1               Move to MSB
00001CC0  1238 1012               1156          MOVE.B  IOLC,D1             Set row to line counter
00001CC4  4E4F                    1157          TRAP    #15
00001CC6  2278 100E               1158          MOVE.L  IOADDR,A1           Point A1 to IOADDR
00001CCA  7402                    1159          MOVE.L  #2,D2               Set size to word
00001CCC  6100 F74A               1160          BSR     DSPHXA              Display hex word
00001CD0  5338 1012               1161          SUB.B   #1,IOLC             Decrement line counter
00001CD4  6000 0044               1162          BRA     PRNTFIN             Branch to PRINT finish
00001CD8  11FC 0000 1013          1163  NOTBAD  MOVE.B  #0,(IOBC)           Reset bad counter
00001CDE  6100 FEA0               1164          BSR     DISPADR             Display address
00001CE2  6100 FEB6               1165          BSR     DISPRAW             Display raw data
00001CE6  6100 FE08               1166          BSR     DISPINS             Display instruction
00001CEA  54B8 100E               1167          ADD.L   #2,(IOADDR)         Move memory location past first word
00001CEE  6100 FE50               1168  PRINTS  BSR     DISPSRC             Get source display
00001CF2  6608                    1169          BNE     *+10                If source does not exist, skip the next two lines
00001CF4  183C 0001               1170          MOVE.B  #1,D4               Else, set source to true
00001CF8  6100 F918               1171          BSR     DISPOP              Display accordingly
00001CFC  6100 FE62               1172  PRINTD  BSR     DISPDST             Get destination display
00001D00  6600 0018               1173          BNE     PRNTFIN             If dest does not exists, skip to PRINT finish
00001D04  103C 0006               1174          MOVE.B  #6,D0               Display character
00001D08  123C 002C               1175          MOVE.B  #',',D1             Read comma
00001D0C  B83C 0001               1176          CMP.B   #1,D4               Test if source was displayed
00001D10  6600 0000               1177          BNE     *+2                 If it was not displayed, don't display a comma
00001D14  4E4F                    1178          TRAP    #15                 If it was displayed, display a comma
00001D16  6100 F8FA               1179          BSR     DISPOP              Display destination accordingly
00001D1A  6100 FECE               1180  PRNTFIN BSR     DISPANO             Display annotation(s)
00001D1E  6100 002C               1181          BSR     RESETIO             Reset IO values
00001D22  54B8 1000               1182          ADD.L   #$2,(GBUFF)         Advance buffer past instruction
00001D26  5238 1012               1183          ADD.B   #1,IOLC
00001D2A  0C38 001E 1012          1184          CMP.B   #30,IOLC            Compare #30 to line counter
00001D30  6700 0056               1185          BEQ     PAUSE               If ==, branch to PAUSE
00001D34  6100 0042               1186          BSR     CHKEND              Check for end of program
00001D38  0C38 0001 1012          1187          CMP.B   #1,IOLC             Compare #1 to line counter
00001D3E  6600 0110               1188          BNE     OP                  If !=, branch to OP for next instruction
00001D42  21F8 1000 1004          1189          MOVE.L  (GBUFF),(NGBUFF)    Else, store GBUFF in NGBUFF
00001D48  6000 0106               1190          BRA     OP                  Branch to OP for next instruction
00001D4C                          1191  
00001D4C                          1192  * Reset I/O instruction values
00001D4C  31FC 00FF 1008          1193  RESETIO MOVE.W  #$FF,(IOOPCD)
00001D52  31FC 00FF 100A          1194          MOVE.W  #$FF,(IOBDCD)
00001D58  11FC 00FF 100C          1195          MOVE.B  #$FF,(IOSIZE)
00001D5E  11FC 00FF 115A          1196          MOVE.B  #$FF,(SMD)
00001D64  11FC 00FF 115B          1197          MOVE.B  #$FF,(SRG)
00001D6A  11FC 00FF 1158          1198          MOVE.B  #$FF,(DMD)
00001D70  11FC 00FF 1159          1199          MOVE.B  #$FF,(DRG)
00001D76  4E75                    1200          RTS
00001D78                          1201  
00001D78                          1202  * Check if the end of the program has been reached
00001D78  2078 1000               1203  CHKEND  MOVE.L  GBUFF,A0            Set A0 to GBUFF location
00001D7C  B1FC 00002F18           1204          CMPA.L  #ELOC,A0            Compare next buffer to ending location
00001D82  6E00 007E               1205          BGT     DONE                Branch to DONE if > ending location
00001D86  4E75                    1206          RTS                         Else, return to caller
00001D88                          1207  
00001D88                          1208  *
00001D88                          1209  * Pause: Halt the instruction display process, and prompt for an action
00001D88                          1210  *
00001D88                          1211  
00001D88  103C 000B               1212  PAUSE   MOVE.B  #11,D0              Else, position cursor col/row
00001D8C  323C 001F               1213          MOVE.W  #$001F,D1           Last row first column
00001D90  4E4F                    1214          TRAP    #15
00001D92  43F8 115E               1215          LEA     MSSG4,A1            Display keypress prompt
00001D96  103C 000E               1216          MOVE.B  #14,D0              Display A1 until null char
00001D9A  4E4F                    1217          TRAP    #15
00001D9C                          1218  
00001D9C                          1219  *
00001D9C                          1220  * Request Key: Request a keyboard input, and do not continue until a valid input was given
00001D9C                          1221  *
00001D9C                          1222  
00001D9C  103C 000C               1223  REQKEY  MOVE.B  #12,D0              Keyboard echo
00001DA0  123C 0000               1224          MOVE.B  #0,D1               Hidden
00001DA4  4E4F                    1225          TRAP    #15
00001DA6  103C 0005               1226          MOVE.B  #5,D0               Request keyboard input
00001DAA  4E4F                    1227          TRAP    #15
00001DAC  B23C 000D               1228          CMP.B   #$D,D1              Compare input to ENTER
00001DB0  6700 0022               1229          BEQ     DSPHDR              If ==, branch to DSPHDR
00001DB4  B23C 0008               1230          CMP.B   #$8,D1              Compare input to BACKSPACE
00001DB8  6700 F48C               1231          BEQ     START               If ==, branch to RESTART
00001DBC  B23C 0030               1232          CMP.B   #$30,D1             Compare input to [0]
00001DC0  6700 0070               1233          BEQ     HALT                If ==, branch to HALT
00001DC4  B23C 000A               1234          CMP.B   #$A,D1              Compare input to CTR + ENTER
00001DC8  66D2                    1235          BNE     REQKEY              If !=, loop until a recognized key code was entered
00001DCA  21F8 1004 1000          1236          MOVE.L  (NGBUFF),(GBUFF)    Else, go down one line
00001DD0  6000 0002               1237          BRA     DSPHDR              Branch to DSPHDR
00001DD4                          1238  
00001DD4                          1239  *
00001DD4                          1240  * Display Header: Display the column headers and reset the counters
00001DD4                          1241  *
00001DD4                          1242  
00001DD4  103C 000C               1243  DSPHDR  MOVE.B  #12,D0              Keyboard echo
00001DD8  123C 0001               1244          MOVE.B  #1,D1               Visible
00001DDC  4E4F                    1245          TRAP    #15
00001DDE  103C 000B               1246          MOVE.B  #11,D0              Clear the screen
00001DE2  323C FF00               1247          MOVE.W  #$FF00,D1
00001DE6  4E4F                    1248          TRAP    #15
00001DE8  43F8 11F3               1249          LEA     HEADR,A1            Display header
00001DEC  103C 000E               1250          MOVE.B  #14,D0              Display A1 until null char
00001DF0  4E4F                    1251          TRAP    #15
00001DF2  4238 1012               1252          CLR.B   (IOLC)              Reset line counter
00001DF6  4238 1013               1253          CLR.B   (IOBC)              Reset bad counter
00001DFA  6100 FF7C               1254          BSR     CHKEND              Check for end of program        
00001DFE  6000 0050               1255          BRA     OP                  Branch to OP
00001E02                          1256  
00001E02                          1257  *
00001E02                          1258  * Done: Display the ending message, and halt the program
00001E02                          1259  *
00001E02                          1260  
00001E02  103C 000B               1261  DONE    MOVE.B  #11,D0              Else, position cursor col/row
00001E06  323C 001F               1262          MOVE.W  #$001F,D1           Last row first column
00001E0A  4E4F                    1263          TRAP    #15
00001E0C  43F8 11A2               1264          LEA     MSSG5,A1            Display end message
00001E10  103C 000E               1265          MOVE.B  #14,D0              Display A1 until null char
00001E14  4E4F                    1266          TRAP    #15
00001E16  103C 000C               1267          MOVE.B  #12,D0              Keyboard echo
00001E1A  123C 0000               1268          MOVE.B  #0,D1               Hidden
00001E1E  4E4F                    1269          TRAP    #15
00001E20  103C 0005               1270          MOVE.B  #5,D0               Request keyboard input
00001E24  4E4F                    1271          TRAP    #15
00001E26  B23C 0030               1272          CMP.B   #$30,D1             Compare input to 0
00001E2A  6700 0006               1273          BEQ     HALT                If ==, branch to halt
00001E2E                          1274  
00001E2E  6000 F416               1275          BRA     START
00001E32                          1276  
00001E32                          1277  *
00001E32                          1278  * Halt: Halt the program
00001E32                          1279  *
00001E32                          1280  
00001E32  103C 0009               1281  HALT    MOVE.B  #9,D0               Terminate the program
00001E36  4E4F                    1282          TRAP    #15
00001E38                          1283  
00001E38                          1284  *--------------------
00001E38                          1285  *   OP
00001E38                          1286  *--------------------
00001E38                          1287  
00001E38                          1288  *
00001E38                          1289  * Jump Mask: Use CMPMSK, and jumps to the OP branch if it returns true
00001E38                          1290  * Input CMPMSK inputs, input A0 for OP branch
00001E38                          1291  *
00001E38                          1292  
00001E38  6100 F58E               1293  JMPMSK  BSR     CMPMSK              Branch to CMPMSK
00001E3C  6610                    1294          BNE.S   *+18                If the bits did not match, return to caller
00001E3E  4E90                    1295          JSR     (A0)                If the bits matched, branch to the OP address
00001E40  660A                    1296          BNE     *+12                If the OP address was read successful, skip the next two lines
00001E42  21C9 1000               1297          MOVE.L  A1,(GBUFF)          The buffer was good, move it to GBUFF
00001E46  6000 FE1C               1298          BRA     PRINT               Branch to PRINT     
00001E4A  2278 1000               1299          MOVE.L  GBUFF,A1            The buffer was bad, restore A1
00001E4E  4E75                    1300          RTS                         Return to caller for next instruction
00001E50                          1301  
00001E50  2078 1000               1302  OP      MOVE.L  GBUFF,A0            Set A0 to GBUFF location
00001E54  2278 1000               1303          MOVE.L  GBUFF,A1            Set A1 to GBUFF location for sub-routines
00001E58  3018                    1304          MOVE.W  (A0)+,D0            Transfer word data to D0, post-increment location
00001E5A  3218                    1305          MOVE.W  (A0)+,D1            Transfer next word data to D1, post-increment location
00001E5C  21F8 1000 100E          1306          MOVE.L  GBUFF,IOADDR        Set memory location for IO
00001E62                          1307  *-----
00001E62                          1308  * 0000
00001E62                          1309  *-----
00001E62                          1310          * ORI:    00000000XXXXXXXX
00001E62  343C 0000               1311          MOVE.W  #%0000000000000000,D2
00001E66  363C FF00               1312          MOVE.W  #%1111111100000000,D3
00001E6A  207C 000024AC           1313          MOVE.L  #BRORI,A0
00001E70  61C6                    1314          BSR     JMPMSK
00001E72                          1315  
00001E72                          1316          * ANDI:   00000010XXXXXXXX
00001E72  343C 0200               1317          MOVE.W  #%0000001000000000,D2
00001E76  363C FD00               1318          MOVE.W  #%1111110100000000,D3
00001E7A  207C 000024B4           1319          MOVE.L  #BRANDI,A0
00001E80  61B6                    1320          BSR     JMPMSK
00001E82                          1321  
00001E82                          1322          * SUBI:   00000100XXXXXXXX
00001E82  343C 0400               1323          MOVE.W  #%0000010000000000,D2
00001E86  363C FB00               1324          MOVE.W  #%1111101100000000,D3
00001E8A  207C 000024BE           1325          MOVE.L  #BRSUBI,A0
00001E90  61A6                    1326          BSR     JMPMSK
00001E92                          1327  
00001E92                          1328          * ADDI:   00000110XXXXXXXX
00001E92  343C 0600               1329          MOVE.W  #%0000011000000000,D2
00001E96  363C F900               1330          MOVE.W  #%1111100100000000,D3
00001E9A  207C 000024C8           1331          MOVE.L  #BRADDI,A0
00001EA0  6196                    1332          BSR     JMPMSK
00001EA2                          1333  
00001EA2                          1334          * BTST:   0000100000XXXXXX
00001EA2  343C 0800               1335          MOVE.W  #%0000100000000000,D2
00001EA6  363C F7C0               1336          MOVE.W  #%1111011111000000,D3
00001EAA  207C 00002682           1337          MOVE.L  #BRBTST,A0
00001EB0  6186                    1338          BSR     JMPMSK
00001EB2                          1339  
00001EB2                          1340          * EORI:   00001010XXXXXXXX
00001EB2  343C 0A00               1341          MOVE.W  #%0000101000000000,D2
00001EB6  363C F500               1342          MOVE.W  #%1111010100000000,D3
00001EBA  207C 000024D2           1343          MOVE.L  #BREORI,A0
00001EC0  6100 FF76               1344          BSR     JMPMSK
00001EC4                          1345  
00001EC4                          1346          * CMPI:   00001100XXXXXXXX
00001EC4  343C 0C00               1347          MOVE.W  #%0000110000000000,D2
00001EC8  363C F300               1348          MOVE.W  #%1111001100000000,D3
00001ECC  207C 000024DC           1349          MOVE.L  #BRCMPI,A0
00001ED2  6100 FF64               1350          BSR     JMPMSK
00001ED6                          1351  
00001ED6                          1352          * BTST:   0000XXX100XXXXXX
00001ED6  343C 0100               1353          MOVE.W  #%0000000100000000,D2
00001EDA  363C F0C0               1354          MOVE.W  #%1111000011000000,D3
00001EDE  207C 00002682           1355          MOVE.L  #BRBTST,A0
00001EE4  6100 FF52               1356          BSR     JMPMSK
00001EE8                          1357  
00001EE8                          1358  *-----
00001EE8                          1359  * 0001
00001EE8                          1360  *-----
00001EE8                          1361          * MOVE.B: 0001XXXXXXXXXXXX
00001EE8  343C 1000               1362          MOVE.W  #%0001000000000000,D2
00001EEC  363C E000               1363          MOVE.W  #%1110000000000000,D3
00001EF0  207C 00002A6C           1364          MOVE.L  #BRMOVE,A0
00001EF6  6100 FF40               1365          BSR     JMPMSK
00001EFA                          1366  *-----
00001EFA                          1367  * 0010
00001EFA                          1368  *-----
00001EFA                          1369          * MOVE.L: 0010XXXXXXXXXXXX
00001EFA  343C 2000               1370          MOVE.W  #%0010000000000000,D2
00001EFE  363C D000               1371          MOVE.W  #%1101000000000000,D3
00001F02  207C 00002A6C           1372          MOVE.L  #BRMOVE,A0
00001F08  6100 FF2E               1373          BSR     JMPMSK
00001F0C                          1374  *-----
00001F0C                          1375  * 0011
00001F0C                          1376  *-----
00001F0C                          1377          * MOVE.W: 0011XXXXXXXXXXXX 
00001F0C  343C 3000               1378          MOVE.W  #%0011000000000000,D2
00001F10  363C C000               1379          MOVE.W  #%1100000000000000,D3
00001F14  207C 00002A6C           1380          MOVE.L  #BRMOVE,A0
00001F1A  6100 FF1C               1381          BSR     JMPMSK
00001F1E                          1382  *-----
00001F1E                          1383  * 0100
00001F1E                          1384  *-----
00001F1E                          1385  
00001F1E                          1386          * CLR:    01000010XXXXXXXX
00001F1E  343C 4200               1387          MOVE.W  #%0100001000000000,D2
00001F22  363C BD00               1388          MOVE.W  #%1011110100000000,D3
00001F26  207C 00002E40           1389          MOVE.L  #BRCLR,A0
00001F2C  6100 FF0A               1390          BSR     JMPMSK
00001F30                          1391  
00001F30                          1392          * NEG:    01000100XXXXXXXX
00001F30  343C 4400               1393          MOVE.W  #%0100010000000000,D2
00001F34  363C BB00               1394          MOVE.W  #%1011101100000000,D3
00001F38  207C 00002EE2           1395          MOVE.L  #BRNEG,A0
00001F3E  6100 FEF8               1396          BSR     JMPMSK
00001F42                          1397  
00001F42                          1398          * NOT:    01000110XXXXXXXX
00001F42  343C 4600               1399          MOVE.W  #%0100011000000000,D2
00001F46  363C B900               1400          MOVE.W  #%1011100100000000,D3
00001F4A  207C 00002DAE           1401          MOVE.L  #BRNOT,A0
00001F50  6100 FEE6               1402          BSR     JMPMSK
00001F54                          1403  
00001F54                          1404          * EXT:    0100100XXX000XXX
00001F54  343C 4800               1405          MOVE.W  #%0100100000000000,D2
00001F58  363C B638               1406          MOVE.W  #%1011011000111000,D3
00001F5C  207C 00002EAC           1407          MOVE.L  #BREXT,A0
00001F62  6100 FED4               1408          BSR     JMPMSK
00001F66                          1409  
00001F66                          1410          * TST:    01001010XXXXXXXX
00001F66  343C 4A00               1411          MOVE.W  #%0100101000000000,D2
00001F6A  363C B500               1412          MOVE.W  #%1011010100000000,D3
00001F6E  207C 00002E76           1413          MOVE.L  #BRTST,A0
00001F74  6100 FEC2               1414          BSR     JMPMSK
00001F78                          1415  
00001F78                          1416          * MOVEM:  01001X001XXXXXXX
00001F78  343C 4880               1417          MOVE.W  #%0100100010000000,D2
00001F7C  363C B300               1418          MOVE.W  #%1011001100000000,D3
00001F80  207C 00002B72           1419          MOVE.L  #BRMOVEM,A0
00001F86  6100 FEB0               1420          BSR     JMPMSK
00001F8A                          1421  
00001F8A                          1422          * NOP:    0100111001110001
00001F8A  343C 4E71               1423          MOVE.W  #%0100111001110001,D2
00001F8E  363C B18E               1424          MOVE.W  #%1011000110001110,D3
00001F92  207C 00002E0C           1425          MOVE.L  #BRNOP,A0
00001F98  6100 FE9E               1426          BSR     JMPMSK
00001F9C                          1427  
00001F9C                          1428          * RTE:    0100111001110011
00001F9C  343C 4E73               1429          MOVE.W  #%0100111001110011,D2
00001FA0  363C B18C               1430          MOVE.W  #%1011000110001100,D3
00001FA4  207C 00002DEE           1431          MOVE.L  #BRRTE,A0
00001FAA  6100 FE8C               1432          BSR     JMPMSK
00001FAE                          1433  
00001FAE                          1434          * RTD:    0100111001110100
00001FAE  343C 4E74               1435          MOVE.W  #%0100111001110100,D2
00001FB2  363C B18B               1436          MOVE.W  #%1011000110001011,D3
00001FB6  207C 00002DF8           1437          MOVE.L  #BRRTD,A0
00001FBC  6100 FE7A               1438          BSR     JMPMSK
00001FC0                          1439  
00001FC0                          1440          * RTS:    0100111001110101
00001FC0  343C 4E75               1441          MOVE.W  #%0100111001110101,D2
00001FC4  363C B18A               1442          MOVE.W  #%1011000110001010,D3
00001FC8  207C 00002DE4           1443          MOVE.L  #BRRTS,A0
00001FCE  6100 FE68               1444          BSR     JMPMSK
00001FD2                          1445  
00001FD2                          1446          * RTR:    0100111001110111
00001FD2  343C 4E77               1447          MOVE.W  #%0100111001110111,D2
00001FD6  363C B188               1448          MOVE.W  #%1011000110001000,D3
00001FDA  207C 00002E02           1449          MOVE.L  #BRRTR,A0
00001FE0  6100 FE56               1450          BSR     JMPMSK
00001FE4                          1451  
00001FE4                          1452          * JSR:    0100111010XXXXXX
00001FE4  343C 4E80               1453          MOVE.W  #%0100111010000000,D2
00001FE8  363C B140               1454          MOVE.W  #%1011000101000000,D3
00001FEC  207C 00002A30           1455          MOVE.L  #BRJSR,A0
00001FF2  6100 FE44               1456          BSR     JMPMSK
00001FF6                          1457      
00001FF6                          1458          * JMP:    0100111011XXXXXX
00001FF6  343C 4EC0               1459          MOVE.W  #%0100111011000000,D2
00001FFA  363C B100               1460          MOVE.W  #%1011000100000000,D3
00001FFE  207C 00002A4E           1461          MOVE.L  #BRJMP,A0
00002004  6100 FE32               1462          BSR     JMPMSK
00002008                          1463  
00002008                          1464          * TRAP:   010011100100XXXX
00002008  343C 4E40               1465          MOVE.W  #%0100111001000000,D2
0000200C  363C B1B0               1466          MOVE.W  #%1011000110110000,D3
00002010  207C 00002E16           1467          MOVE.L  #BRTRAP,A0
00002016  6100 FE20               1468          BSR     JMPMSK
0000201A                          1469  
0000201A                          1470          * LEA:    0100XXX111XXXXXX
0000201A  343C 41C0               1471          MOVE.W  #%0100000111000000,D2
0000201E  363C B000               1472          MOVE.W  #%1011000000000000,D3
00002022  207C 00002A08           1473          MOVE.L  #BRLEA,A0
00002028  6100 FE0E               1474          BSR     JMPMSK
0000202C                          1475  
0000202C                          1476          * SWAP:   0100100001000XXX
0000202C  343C 4840               1477          MOVE.W  #%0100100001000000,D2
00002030  363C B7B8               1478          MOVE.W  #%1011011110111000,D3
00002034  207C 00002E2C           1479          MOVE.L  #BRSWAP,A0
0000203A  6100 FDFC               1480          BSR     JMPMSK
0000203E                          1481  
0000203E                          1482          * MOVE...:0100001011XXXXXX
0000203E                          1483          * ...from CCR
0000203E  343C 42C0               1484          MOVE.W  #%0100001011000000,D2
00002042  363C BD00               1485          MOVE.W  #%1011110100000000,D3
00002046  207C 00002AE2           1486          MOVE.L  #BRMFCCR,A0
0000204C  6100 FDEA               1487          BSR     JMPMSK
00002050                          1488  
00002050                          1489          * MOVE...:0100010011XXXXXX
00002050                          1490          * ...to CCR
00002050  343C 44C0               1491          MOVE.W  #%0100010011000000,D2
00002054  363C BB00               1492          MOVE.W  #%1011101100000000,D3
00002058  207C 00002B16           1493          MOVE.L  #BRMTCCR,A0
0000205E  6100 FDD8               1494          BSR     JMPMSK
00002062                          1495  *-----
00002062                          1496  * 0101
00002062                          1497  *-----
00002062                          1498          * ADDQ:   0101XXX0XXXXXXXX
00002062  343C 5000               1499          MOVE.W  #%0101000000000000,D2
00002066  363C A100               1500          MOVE.W  #%1010000100000000,D3
0000206A  207C 0000255E           1501          MOVE.L  #BRADDQ,A0
00002070  6100 FDC6               1502          BSR     JMPMSK
00002074                          1503  
00002074                          1504          * SUBQ:   0101XXX1XXXXXXXX
00002074  343C 5100               1505          MOVE.W  #%0101000100000000,D2
00002078  363C A000               1506          MOVE.W  #%1010000000000000,D3
0000207C  207C 000025E0           1507          MOVE.L  #BRSUBQ,A0
00002082  6100 FDB4               1508          BSR     JMPMSK
00002086                          1509  
00002086                          1510          *DBcc:    0101XXXX11001XXX
00002086  343C 50C8               1511          MOVE.W  #%0101000011001000,D2
0000208A  363C A030               1512          MOVE.W  #%1010000000110000,D3
0000208E  207C 00002854           1513          MOVE.L  #BRDBccd,A0
00002094  6100 FDA2               1514          BSR     JMPMSK
00002098                          1515  
00002098                          1516  *-----
00002098                          1517  * 0110
00002098                          1518  *-----
00002098                          1519          * Bcc:    0110XXXXXXXXXXXX
00002098  343C 6000               1520          MOVE.W  #%0110000000000000,D2
0000209C  363C 9000               1521          MOVE.W  #%1001000000000000,D3
000020A0  207C 00002728           1522          MOVE.L  #BRBccd,A0
000020A6  6100 FD90               1523          BSR     JMPMSK
000020AA                          1524  *-----
000020AA                          1525  * 0111
000020AA                          1526  *-----
000020AA                          1527          * MOVEQ:  0111XXX0XXXXXXXX
000020AA  343C 7000               1528          MOVE.W  #%0111000000000000,D2
000020AE  363C 8100               1529          MOVE.W  #%1000000100000000,D3
000020B2  207C 00002C0E           1530          MOVE.L  #BRMOVEQ,A0
000020B8  6100 FD7E               1531          BSR     JMPMSK
000020BC                          1532  *-----
000020BC                          1533  * 1000
000020BC                          1534  *-----
000020BC                          1535          * DIVU:   1000XXX011XXXXXX
000020BC  343C 80C0               1536          MOVE.W  #%1000000011000000,D2
000020C0  363C 7100               1537          MOVE.W  #%0111000100000000,D3
000020C4  207C 00002D6A           1538          MOVE.L  #BRDIVU,A0
000020CA  6100 FD6C               1539          BSR     JMPMSK
000020CE                          1540  
000020CE                          1541          * DIVS:   1000XXX111XXXXXX
000020CE  343C 81C0               1542          MOVE.W  #%1000000111000000,D2
000020D2  363C 7000               1543          MOVE.W  #%0111000000000000,D3
000020D6  207C 00002D7A           1544          MOVE.L  #BRDIVS,A0
000020DC  6100 FD5A               1545          BSR     JMPMSK
000020E0                          1546  
000020E0                          1547          * OR:     1000XXXXXXXXXXXX
000020E0  343C 8000               1548          MOVE.W  #%1000000000000000,D2
000020E4  363C 7000               1549          MOVE.W  #%0111000000000000,D3
000020E8  207C 00002636           1550          MOVE.L  #BROR,A0
000020EE  6100 FD48               1551          BSR     JMPMSK
000020F2                          1552  *-----
000020F2                          1553  * 1001
000020F2                          1554  *-----
000020F2                          1555          * SUB:    1001XXXXXXXXXXXX
000020F2  343C 9000               1556          MOVE.W  #%1001000000000000,D2
000020F6  363C 6000               1557          MOVE.W  #%0110000000000000,D3
000020FA  207C 00002568           1558          MOVE.L  #BRSUB,A0
00002100  6100 FD36               1559          BSR     JMPMSK
00002104                          1560  *-----
00002104                          1561  * 1010
00002104                          1562  *-----
00002104                          1563  *-----
00002104                          1564  * 1011
00002104                          1565  *-----
00002104                          1566          * CMP:    1011XXXXXXXXXXXX
00002104  343C B000               1567          MOVE.W  #%1011000000000000,D2
00002108  363C 4000               1568          MOVE.W  #%0100000000000000,D3
0000210C  207C 0000296C           1569          MOVE.L  #BRCMP,A0
00002112  6100 FD24               1570          BSR     JMPMSK
00002116                          1571  
00002116                          1572          * EOR:    1011XXXXXXXXXXXX
00002116  343C B000               1573          MOVE.W  #%1011000000000000,D2
0000211A  363C 4000               1574          MOVE.W  #%0100000000000000,D3
0000211E  207C 000029D2           1575          MOVE.L  #BREOR,A0
00002124  6100 FD12               1576          BSR     JMPMSK
00002128                          1577  *-----
00002128                          1578  * 1100
00002128                          1579  *-----
00002128                          1580          * AND:    1100XXXXXXXXXXXX
00002128  343C C000               1581          MOVE.W  #%1100000000000000,D2
0000212C  363C 3000               1582          MOVE.W  #%0011000000000000,D3
00002130  207C 000025EA           1583          MOVE.L  #BRAND,A0
00002136  6100 FD00               1584          BSR     JMPMSK
0000213A                          1585  
0000213A                          1586          * MULU:   1100XXX011XXXXXX
0000213A  343C C0C0               1587          MOVE.W  #%1100000011000000,D2
0000213E  363C 3100               1588          MOVE.W  #%0011000100000000,D3
00002142  207C 00002D4A           1589          MOVE.L  #BRMULU,A0
00002148  6100 FCEE               1590          BSR     JMPMSK
0000214C                          1591  
0000214C                          1592          * MULS:   1100XXX111XXXXXX
0000214C  343C C1C0               1593          MOVE.W  #%1100000111000000,D2
00002150  363C 3000               1594          MOVE.W  #%0011000000000000,D3
00002154  207C 00002D5A           1595          MOVE.L  #BRMULS,A0
0000215A  6100 FCDC               1596          BSR     JMPMSK
0000215E                          1597  *-----
0000215E                          1598  * 1101
0000215E                          1599  *-----
0000215E                          1600          * ADD:    1101XXXXXXXXXXXX
0000215E  343C D000               1601          MOVE.W  #%1101000000000000,D2
00002162  363C 2000               1602          MOVE.W  #%0010000000000000,D3
00002166  207C 000024E6           1603          MOVE.L  #BRADD,A0
0000216C  6100 FCCA               1604          BSR     JMPMSK
00002170                          1605  *-----
00002170                          1606  * 1110
00002170                          1607  *-----
00002170                          1608          * ASL/ASR:1110000X11XXXXXX
00002170  343C E0C0               1609          MOVE.W  #%1110000011000000,D2
00002174  363C 1E00               1610          MOVE.W  #%0001111000000000,D3
00002178  207C 00002C64           1611          MOVE.L  #BRASd,A0
0000217E  6100 FCB8               1612          BSR     JMPMSK
00002182                          1613  
00002182                          1614          * LSL/LSR:1110001X11XXXXXX
00002182  343C E2C0               1615          MOVE.W  #%1110001011000000,D2
00002186  363C 1C00               1616          MOVE.W  #%0001110000000000,D3
0000218A  207C 00002C94           1617          MOVE.L  #BRLSd,A0
00002190  6100 FCA6               1618          BSR     JMPMSK
00002194                          1619  
00002194                          1620          * ROL/ROR:1110011X11XXXXXX
00002194  343C E6C0               1621          MOVE.W  #%1110011011000000,D2
00002198  363C 1800               1622          MOVE.W  #%0001100000000000,D3
0000219C  207C 00002C34           1623          MOVE.L  #BRROd,A0
000021A2  6100 FC94               1624          BSR     JMPMSK
000021A6                          1625  
000021A6                          1626          * ASL/ASR:1110XXXXXXX00XXX
000021A6  343C E000               1627          MOVE.W  #%1110000000000000,D2
000021AA  363C 1018               1628          MOVE.W  #%0001000000011000,D3
000021AE  207C 00002C64           1629          MOVE.L  #BRASd,A0
000021B4  6100 FC82               1630          BSR     JMPMSK
000021B8                          1631  
000021B8                          1632          * LSL/LSR:1110XXXXXXX01XXX
000021B8  343C E008               1633          MOVE.W  #%1110000000001000,D2
000021BC  363C 1010               1634          MOVE.W  #%0001000000010000,D3
000021C0  207C 00002C94           1635          MOVE.L  #BRLSd,A0
000021C6  6100 FC70               1636          BSR     JMPMSK
000021CA                          1637  
000021CA                          1638          * ROL/ROR:1110XXXXXXX11XXX
000021CA  343C E018               1639          MOVE.W  #%1110000000011000,D2
000021CE  363C 1000               1640          MOVE.W  #%0001000000000000,D3
000021D2  207C 00002C34           1641          MOVE.L  #BRROd,A0
000021D8  6100 FC5E               1642          BSR     JMPMSK
000021DC                          1643  
000021DC                          1644  *-----
000021DC                          1645  * 1111
000021DC                          1646  *-----     
000021DC  6000 FA46               1647          BRA     BRBAD           No mask matched, branch to PRINT
000021E0                          1648  
000021E0                          1649  *--------------------------
000021E0                          1650  *  Instruction Subroutines
000021E0                          1651  *--------------------------
000021E0                          1652  
000021E0                          1653  *
000021E0                          1654  * Test Addressing Modes: Tests last register and mode for valid addressing modes
000021E0                          1655  * Input valid modes in D0.W, output found addressing mode to D1.B, or FF if not found
000021E0                          1656  * Set Z-flag if mode was valid, or clear Z-flag if mode was invalid
000021E0                          1657  *
000021E0                          1658  * D0.W addressing modes (set to 0 for invalid, 1 for valid):
000021E0                          1659  *   0   Dn
000021E0                          1660  *   1   An
000021E0                          1661  *   2   (An)
000021E0                          1662  *   3   (An)+
000021E0                          1663  *   4   -(An)
000021E0                          1664  *   5   (d,An)
000021E0                          1665  *   6   (d,An,Xn)
000021E0                          1666  *   7   (xxx).W
000021E0                          1667  *   8   (xxx).L
000021E0                          1668  *   9   (d,PC)
000021E0                          1669  *   A   (d,PC,Xn)
000021E0                          1670  *   B   #<data>
000021E0                          1671  *
000021E0                          1672  * Modes         %XXXXBA9876543210
000021E0  =00000FFF               1673  M_ALL   EQU     %0000111111111111   All modes
000021E0  =00000FFD               1674  M_DAT   EQU     %0000111111111101   Data modes
000021E0  =00000FFC               1675  M_MEM   EQU     %0000111111111100   Memory modes
000021E0  =000007E4               1676  M_CTR   EQU     %0000011111100100   Control modes
000021E0  =0000007F               1677  M_ALT   EQU     %0000000001111111   Alterable modes
000021E0  =000001FC               1678  M_MALT  EQU     %0000000111111100   Memory alterable modes
000021E0  =000001FD               1679  M_DALT  EQU     %0000000111111101   Data alterable modes
000021E0  =000001FF               1680  M_EAALT EQU     %0000000111111111   EA alterable modes
000021E0                          1681  
000021E0  1F02                    1682  TSTAM   MOVE.B  D2,-(SP)        Push D2 to stack
000021E2  4281                    1683          CLR.L   D1
000021E4  1238 115C               1684          MOVE.B  (RGMD),D1       Move REGMOD to D1
000021E8  1401                    1685          MOVE.B  D1,D2           Copy REGMOD to D2
000021EA  EB09                    1686          LSL.B   #5,D1
000021EC  EA09                    1687          LSR.B   #5,D1           D1 = Mode
000021EE  E60A                    1688          LSR.B   #3,D2           D2 = Register
000021F0  B23C 0007               1689          CMP.B   #%111,D1        Test mode to 111
000021F4  6602                    1690          BNE     *+4             If !=, skip next line
000021F6  D202                    1691          ADD.B   D2,D1           Add register to mode-- effectively creating a 4 bit mode
000021F8  0300                    1692          BTST    D1,D0           Test mode for validity
000021FA  6706                    1693          BEQ     *+8             If it is invalid, skip to clear flag
000021FC  141F                    1694          MOVE.B  (SP)+,D2        If it is valid, restore D2
000021FE  6000 F086               1695          BRA     FLAGST          Set flag & return to caller
00002202  141F                    1696          MOVE.B  (SP)+,D2        Restore D2
00002204  6000 F086               1697          BRA     FLAGCL          Clear flag & return to caller
00002208                          1698  
00002208                          1699  *
00002208                          1700  * Advance Buffer: Advances buffer based on last register and mode
00002208                          1701  * Input buffer in A1, reg & mode in RGMD, output displacement to DIS
00002208                          1702  *
00002208                          1703  
00002208  48E7 6000               1704  ADVBFR  MOVEM.L D1/D2,-(SP)     Push D1 & D2 to the stack
0000220C  11FC 00FF 115D          1705          MOVE.B  #$FF,(DIS)      Set displacement to NULL
00002212  1238 115C               1706          MOVE.B  (RGMD),D1       Move Reg & Mod to D1
00002216  2409                    1707          MOVE.L  A1,D2           Copy buffer to D2
00002218  B23C 0007               1708          CMP.B   #$07,D1         Test 000 111 = (XXX).W (Word)
0000221C  6602                    1709          BNE.S   *+4             Skip next line
0000221E  5489                    1710          ADD.L   #2,A1           Advance buffer by word
00002220  B23C 000F               1711          CMP.B   #$0F,D1         Test 001 111 = (XXX).L (Long)
00002224  6602                    1712          BNE.S   *+4             Skip next line
00002226  5889                    1713          ADD.L   #4,A1           Advance buffer by long
00002228  B23C 0017               1714          CMP.B   #$17,D1         Test 010 111 = (d16,PC) (Word)
0000222C  6602                    1715          BNE.S   *+4             Skip next line
0000222E  5489                    1716          ADD.L   #2,A1           Advance buffer by word
00002230  B23C 001F               1717          CMP.B   #$1F,D1         Test 011 111 = (d8,PC,Xn) (Word)
00002234  6602                    1718          BNE.S   *+4             Skip next line
00002236  5489                    1719          ADD.L   #2,A1           Advance buffer by word
00002238  B23C 0027               1720          CMP.B   #$27,D1         Test 100 111 = Immediate (OP code size)
0000223C  6700 0024               1721          BEQ     ADVBSZ          If ==, branch to Advance Buffer by Size
00002240  EB09                    1722          LSL.B   #5,D1           Else, check the mode...
00002242  EA09                    1723          LSR.B   #5,D1           D1 = Mode
00002244  B23C 0005               1724          CMP.B   #5,D1           Test XXX 101 = (d16,An) (Word)
00002248  6602                    1725          BNE     *+4             Skip next line
0000224A  5489                    1726          ADD.L   #2,A1           Advance buffer by word
0000224C  B23C 0006               1727          CMP.B   #6,D1           Test XXX 110 = (d8,An,Xn) (Word)
00002250  6602                    1728          BNE     *+4             Skip next line
00002252  5489                    1729          ADD.L   #2,A1           Advance buffer by word
00002254  4482                    1730          NEG.L   D2              Negate original buffer
00002256  D489                    1731          ADD.L   A1,D2           Add buffer to get difference
00002258  11C2 115D               1732          MOVE.B  D2,(DIS)        Store displacement in DIS
0000225C  4CDF 0006               1733          MOVEM.L (SP)+,D1/D2     Restore D1 & D2
00002260  4E75                    1734          RTS                     Return to caller
00002262                          1735  
00002262                          1736  *
00002262                          1737  * Advance Buffer by Size: Advances buffer based on instruction size
00002262                          1738  * Input buffer in A1, input size from (IOSIZE), output displacement to DIS
00002262                          1739  *
00002262                          1740  
00002262  0C38 00FF 115D          1741  ADVBSZ  CMP.B   #$FF,(DIS)      Check if DIS is NULL (255 is odd so displacement should never be FF)
00002268  6704                    1742          BEQ     *+6             If it is null, values have already been pushed to the stack, skip the next line
0000226A  48E7 6000               1743          MOVEM.L D1/D2,-(SP)     Else, push D1 & D2 to the stack
0000226E  1238 100C               1744          MOVE.B  (IOSIZE),D1     Read size to D1
00002272  2409                    1745          MOVE.L  A1,D2           Copy buffer to D2
00002274  B23C 0000               1746          CMP.B   #0,D1           Test 0 = Byte
00002278  6602                    1747          BNE.S   *+4             Skip next line
0000227A  5489                    1748          ADD.L   #2,A1           Advance buffer by word (00BB)
0000227C  B23C 0001               1749          CMP.B   #1,D1           Test 1 = Word
00002280  6602                    1750          BNE.S   *+4             Skip next line
00002282  5489                    1751          ADD.L   #2,A1           Advance buffer by word        
00002284  B23C 0002               1752          CMP.B   #2,D1           Test 2 = Long
00002288  6602                    1753          BNE.S   *+4             Skip next line
0000228A  5889                    1754          ADD.L   #4,A1           Advance buffer by long
0000228C  4442                    1755          NEG     D2              Negate original buffer
0000228E  D489                    1756          ADD.L   A1,D2           Add buffer to get difference
00002290  11C2 115D               1757          MOVE.B  D2,(DIS)        Store displacement in DIS
00002294  4CDF 0006               1758          MOVEM.L (SP)+,D2/D1     Restore D1 and D2
00002298  4E75                    1759          RTS                     Return to caller
0000229A                          1760  
0000229A                          1761  *
0000229A                          1762  * OP Size: Test the standard OP size code
0000229A                          1763  * Inputs size from (DMD), outputs size to IOSIZE, operation to D2.B, correct mode to DMD
0000229A                          1764  * OPM (OP-MODE):  Byte | Word | Long | Operation | D2.B
0000229A                          1765  *                  000 |  001 |  010 |   <ea>,Dn |    0
0000229A                          1766  *                  100 |  101 |  110 |   Dn,<ea> |    1
0000229A                          1767  *                         011 |  111 |   <ea>,An |    2
0000229A                          1768  *
0000229A                          1769  
0000229A  48E7 C000               1770  OPSIZE  MOVEM.L D0/D1,-(SP)     Push D0 & D1 to stack
0000229E  4241                    1771          CLR.W   D1              Ensure displacement will be <= 7
000022A0  1238 1158               1772          MOVE.B  (DMD),D1        Get destination mode in D1
000022A4  C2FC 0004               1773          MULU.W  #4,D1           Convert to displacement
000022A8  4EFB 1002               1774          JMP     OPTBL(PC,D1.W)  Jump to OP mode
000022AC  6000 001E               1775  OPTBL   BRA     OP0             000
000022B0  6000 002C               1776          BRA     OP1             001
000022B4  6000 003A               1777          BRA     OP2             010
000022B8  6000 0048               1778          BRA     OP3             011
000022BC  6000 0056               1779          BRA     OP4             100
000022C0  6000 0064               1780          BRA     OP5             101
000022C4  6000 0072               1781          BRA     OP6             110
000022C8  6000 0080               1782          BRA     OP7             111
000022CC  143C 0000               1783  OP0     MOVE.B  #0,D2           Set OP to 0 for Dn
000022D0  11FC 0000 1158          1784          MOVE.B  #0,(DMD)        Set mode to Dn
000022D6  103C 0000               1785          MOVE.B  #0,D0           Set size to byte
000022DA  6000 0080               1786          BRA     OP8             Branch to end
000022DE  143C 0000               1787  OP1     MOVE.B  #0,D2           Set OP to 0 for Dn
000022E2  11FC 0000 1158          1788          MOVE.B  #0,(DMD)        Set mode to Dn
000022E8  103C 0001               1789          MOVE.B  #1,D0           Set size to word
000022EC  6000 006E               1790          BRA     OP8             Branch to end
000022F0  143C 0000               1791  OP2     MOVE.B  #0,D2           Set OP to 0 for Dn
000022F4  11FC 0000 1158          1792          MOVE.B  #0,(DMD)        Set mode to Dn
000022FA  103C 0002               1793          MOVE.B  #2,D0           Set size to long
000022FE  6000 005C               1794          BRA     OP8             Branch to end
00002302  143C 0002               1795  OP3     MOVE.B  #2,D2           Set OP to 2 for An
00002306  11FC 0001 1158          1796          MOVE.B  #1,(DMD)        Set mode to An
0000230C  103C 0001               1797          MOVE.B  #1,D0           Set size to word
00002310  6000 004A               1798          BRA     OP8             Branch to end
00002314  143C 0001               1799  OP4     MOVE.B  #1,D2           Set OP to 1 for <ea>
00002318  11FC 0000 1158          1800          MOVE.B  #0,(DMD)        Set mode to Dn
0000231E  103C 0000               1801          MOVE.B  #0,D0           Set size to byte
00002322  6000 0038               1802          BRA     OP8             Branch to end
00002326  143C 0001               1803  OP5     MOVE.B  #1,D2           Set OP to 1 for <ea>
0000232A  11FC 0000 1158          1804          MOVE.B  #0,(DMD)        Set mode to Dn
00002330  103C 0001               1805          MOVE.B  #1,D0           Set size to word
00002334  6000 0026               1806          BRA     OP8             Branch to end
00002338  143C 0001               1807  OP6     MOVE.B  #1,D2           Set OP to 1 for <ea>
0000233C  11FC 0000 1158          1808          MOVE.B  #0,(DMD)        Set mode to Dn
00002342  103C 0002               1809          MOVE.B  #2,D0           Set size to long
00002346  6000 0014               1810          BRA     OP8             Branch to end
0000234A  143C 0002               1811  OP7     MOVE.B  #2,D2           Set OP to 2 for An
0000234E  11FC 0001 1158          1812          MOVE.B  #1,(DMD)        Set mode to An
00002354  103C 0002               1813          MOVE.B  #2,D0           Set size to long
00002358  6000 0002               1814          BRA     OP8             Branch to end
0000235C  11C0 100C               1815  OP8     MOVE.B  D0,(IOSIZE)     Store size in IOSIZE
00002360  1238 1159               1816          MOVE.B  (DRG),D1        Move DRG to D1
00002364  E709                    1817          LSL.B   #3,D1           Shift the reg 3 bits left
00002366  8238 1158               1818          OR.B    (DMD),D1        Add mode after reg
0000236A  11C1 115C               1819          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000236E  4CDF 0003               1820          MOVEM.L (SP)+,D0/D1     Restore D0 & D1
00002372  4E75                    1821          RTS                     Return to caller
00002374                          1822  
00002374                          1823  *
00002374                          1824  * Extract destination: Extracts destination mode to DMD and destination register to DRG from instruction
00002374                          1825  * Input instruction from GBUFF, output a combination of reg & mode in RGMD
00002374                          1826  *
00002374                          1827  
00002374  48E7 E080               1828  EXDST   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
00002378  2078 1000               1829          MOVE.L  GBUFF,A0        Point A0 to GBUFF
0000237C  3010                    1830          MOVE.W  (A0),D0         Move instruction to D0
0000237E  243C 000001C0           1831          MOVE.L  #$1C0,D2        Extract dest mode at 0000000111000000
00002384  6100 F070               1832          BSR     EXTMSK          Get dest mode to D1
00002388  11C1 1158               1833          MOVE.B  D1,(DMD)        Move dest mode to DMD
0000238C  243C 00000E00           1834          MOVE.L  #$E00,D2        Extract dest reg at 0000111000000000
00002392  6100 F062               1835          BSR     EXTMSK          Get dest reg to D1
00002396  11C1 1159               1836          MOVE.B  D1,(DRG)        Move dest reg to (DRG)
0000239A  E709                    1837          LSL.B   #3,D1           Shift the reg 3 bits left
0000239C  8238 1158               1838          OR.B    (DMD),D1        Add mode after reg
000023A0  11C1 115C               1839          MOVE.B  D1,(RGMD)       Store D1 in RGMD
000023A4  4CDF 0107               1840          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2 and A0
000023A8  4E75                    1841          RTS                     Return to caller
000023AA                          1842  
000023AA                          1843  *
000023AA                          1844  * Extract source: Extracts source mode to SMD and source register to SRG from instruction
000023AA                          1845  * Inputs instruction from GBUFF, output a combination of reg & mode in RGMD
000023AA                          1846  *
000023AA                          1847  
000023AA  48E7 E080               1848  EXSRC   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
000023AE  2078 1000               1849          MOVE.L  GBUFF,A0        Point A0 to GBUFF
000023B2  3010                    1850          MOVE.W  (A0),D0         Move instruction to D0
000023B4  7438                    1851          MOVE.L  #$38,D2         Extract src mode at 0000000000111000
000023B6  6100 F03E               1852          BSR     EXTMSK          Get src mode to D1
000023BA  11C1 115A               1853          MOVE.B  D1,(SMD)        Move src mode to (OMD)
000023BE  7407                    1854          MOVE.L  #$7,D2          Extract src reg at 0000000000000111
000023C0  6100 F034               1855          BSR     EXTMSK          Get src reg to D1
000023C4  11C1 115B               1856          MOVE.B  D1,(SRG)        Move src reg to (ORG)
000023C8  E709                    1857          LSL.B   #3,D1           Shift the reg 3 bits left
000023CA  8238 115A               1858          OR.B    (SMD),D1        Add mode after reg
000023CE  11C1 115C               1859          MOVE.B  D1,(RGMD)       Store D1 in RGMD
000023D2  4CDF 0107               1860          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2
000023D6  4E75                    1861          RTS                     Return to caller
000023D8                          1862  
000023D8                          1863  * Swap fields: Swaps the destination and source fields
000023D8  48A7 C000               1864  SWAPF   MOVEM.W D0/D1,-(SP)     Push D0 and D1 to stack
000023DC  1038 1158               1865          MOVE.B  (DMD),D0        Store DMD in D0
000023E0  1238 1159               1866          MOVE.B  (DRG),D1        Store DRG in D1
000023E4  11F8 115A 1158          1867          MOVE.B  (SMD),(DMD)     Move SMD to DMD
000023EA  11F8 115B 1159          1868          MOVE.B  (SRG),(DRG)     Move SRG to DRG
000023F0  11C0 115A               1869          MOVE.B  D0,(SMD)        Move DMD to SMD
000023F4  11C1 115B               1870          MOVE.B  D1,(SRG)        Move DRG to SRG
000023F8  4C9F 0003               1871          MOVEM.W (SP)+,D0/D1     Restore D0 and D1
000023FC  4E75                    1872          RTS                     Return to caller
000023FE                          1873  
000023FE                          1874  * ----------------
000023FE                          1875  * OP Mode Branches
000023FE                          1876  * ----------------
000023FE                          1877  * A1 reserved for tentative good buffer
000023FE                          1878  
000023FE                          1879  
000023FE                          1880  * ARITHMETIC Q Instruction: XXXX|DAT|X|SZ|EMD|ERG
000023FE                          1881  * Syntax: XXXQ      #<1-8>,<ea>
000023FE                          1882  
000023FE  3011                    1883  BRARMQ  MOVE.W  (A1),D0         Move instruction to D0
00002400  243C 000000C0           1884          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002406  6100 EFEE               1885          BSR     EXTMSK          Get the size to D1
0000240A                          1886  
0000240A  B23C 0003               1887          CMP.B   #%11,D1         Compare size to 11
0000240E  6700 EE7C               1888          BEQ     FLAGCL          If ==, it is invalid, branch to clear flag      
00002412  11C1 100C               1889          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002416                          1890  
00002416                          1891          * dest EA field: "Only alterable addressing modes can be used [...]."
00002416  303C 01FF               1892          MOVE.W  #M_EAALT,D0     Set EA alterable modes as valid (0000000011111111)
0000241A  618E                    1893          BSR     EXSRC           Extract destination from source location
0000241C  6100 FDC2               1894          BSR     TSTAM           Test modes for validity
00002420  6600 EE6A               1895          BNE     FLAGCL          If not valid, return unsuccessful
00002424  6100 FDE2               1896          BSR     ADVBFR          Advance the buffer accordingly
00002428                          1897          * manually set the source mode and source register
00002428  11FC 0008 1158          1898          MOVE.B  #8,(DMD)        Set source mode to 3 BEARS CUSTOM
0000242E  11FC 0000 1159          1899          MOVE.B  #0,(DRG)        Set reg mode to 0 for #<1-8>
00002434  61A2                    1900          BSR     SWAPF           Swap the source and destination values
00002436  6000 EE4E               1901          BRA     FLAGST          Return successful
0000243A                          1902  
0000243A                          1903  * IMMEDIATE Instruction: XXXXXXXX|SZ|EMD|ERG
0000243A                          1904  * Syntax: XXXX      #<data>,<ea>
0000243A  3011                    1905  BRIMM   MOVE.W  (A1),D0         Move instruction to D0
0000243C  243C 000000C0           1906          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002442  6100 EFB2               1907          BSR     EXTMSK          Get the size to D1
00002446                          1908  
00002446  B23C 0003               1909          CMP.B   #%11,D1         Compare size to 11
0000244A  6700 EE40               1910          BEQ     FLAGCL          If ==, it is not an immediate instruction, branch to clear flag      
0000244E  11C1 100C               1911          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002452                          1912  
00002452                          1913          * dest EA field: "Only data alterable addressing modes can be used [...]."
00002452  303C 01FD               1914          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002456  6100 FF52               1915          BSR     EXSRC           Extract destination from source location
0000245A  6100 FF7C               1916          BSR     SWAPF           Swap the source to dest values
0000245E  6100 FD80               1917          BSR     TSTAM           Test modes for validity
00002462  6600 0028               1918          BNE     BRIMCCR         If not valid, check if mode was CCR
00002466  6100 FDA0               1919          BSR     ADVBFR          Else, advance the buffer accordingly
0000246A                          1920          * manually set the source mode and source register
0000246A  11FC 0007 115A          1921          MOVE.B  #$07,(SMD)      Set source mode to 111
00002470  11FC 0004 115B          1922          MOVE.B  #$04,(SRG)      Set reg mode to 100 for immediate data
00002476  1238 115B               1923          MOVE.B  (SRG),D1        Copy SRG to D1 to manipulate
0000247A  E709                    1924          LSL.B   #3,D1           Shift the reg 3 bits left
0000247C  8238 115A               1925          OR.B    (SMD),D1        Add mode after reg 
00002480  11C1 115C               1926          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00002484  6100 FD82               1927          BSR     ADVBFR          Advance the buffer accordingly
00002488  6000 EDFC               1928          BRA     FLAGST          Return successful
0000248C                          1929  
0000248C  B23C 000B               1930  BRIMCCR CMP.B   #$0B,D1         Compare mode to #<data>
00002490  6600 EDFA               1931          BNE     FLAGCL          If not valid, branch to FLAGCL
00002494  11FC 0005 1159          1932          MOVE.B  #5,(DRG)        Else, set mode to CCR
0000249A  11FC 000A 115A          1933          MOVE.B  #$A,(SMD)       Set source mode to 3 BEARS CUSTOM next word
000024A0  11FC 0001 115B          1934          MOVE.B  #1,(SRG)        Set reg mode to 1 for #<data>.Q
000024A6  5489                    1935          ADD.L   #2,A1           Advance buffer by word
000024A8  6000 EDDC               1936          BRA     FLAGST          Return successful
000024AC                          1937  
000024AC                          1938  * ORI: 0000|0000|SZ|EMD|ERG
000024AC                          1939  * Syntax: ORI       #<data>,<ea>
000024AC                          1940  
000024AC  31FC 009E 1008          1941  BRORI   MOVE.W  #$09E,(IOOPCD)  Set OP-code name
000024B2  6086                    1942          BRA     BRIMM           Branch to immediate instruction
000024B4                          1943  
000024B4                          1944  * ANDI: 0000|0010|SZ|EMD|ERG
000024B4                          1945  * Syntax: ANDI      #<data>,<ea> 
000024B4                          1946  
000024B4  31FC 0017 1008          1947  BRANDI  MOVE.W  #$017,(IOOPCD)  Set OP-code name
000024BA  6000 FF7E               1948          BRA     BRIMM           Branch to immediate instruction
000024BE                          1949  
000024BE                          1950  * SUBI: 0000|0100|SZ|EMD|ERG
000024BE                          1951  * Syntax: SUBI      #<data>,<ea> 
000024BE                          1952  
000024BE  31FC 0100 1008          1953  BRSUBI  MOVE.W  #$100,(IOOPCD)  Set OP-code name
000024C4  6000 FF74               1954          BRA     BRIMM           Branch to immediate instruction
000024C8                          1955  
000024C8                          1956  * ADDI: 0000|0110|SZ|EMD|ERG
000024C8                          1957  * Syntax: ADDI      #<data>,<ea>
000024C8                          1958  
000024C8  31FC 0009 1008          1959  BRADDI  MOVE.W  #$009,(IOOPCD)  Set OP-code name
000024CE  6000 FF6A               1960          BRA     BRIMM           Branch to immediate instruction
000024D2                          1961  
000024D2                          1962  * EORI: 0000|1010|SZ|EMD|ERG
000024D2                          1963  * Syntax: EORI      #<data>,<ea>
000024D2                          1964  
000024D2  31FC 009D 1008          1965  BREORI  MOVE.W  #$09D,(IOOPCD)  Set OP-code name
000024D8  6000 FF60               1966          BRA     BRIMM           Branch to immediate instruction
000024DC                          1967  
000024DC                          1968  * CMPI: 0000|1100|SZ|EMD|ERG
000024DC                          1969  * Syntax: CMPI      #<data>,<ea>
000024DC                          1970  
000024DC  31FC 003A 1008          1971  BRCMPI  MOVE.W  #$03A,(IOOPCD)  Set OP-code name
000024E2  6000 FF56               1972          BRA     BRIMM           Branch to immediate instruction
000024E6                          1973  
000024E6                          1974  * ADD: 1101|REG|OPM|EMD|ERG
000024E6                          1975  * Syntax: ADD       <ea>,Dn
000024E6                          1976  *         ADD       Dn,<ea>
000024E6                          1977  * Note: The Dn mode is used when the destination is a data register;
000024E6                          1978  *       the destination <ea> mode is invalid for a data register. 
000024E6                          1979  *       ADDA is used when the destination is an address register.
000024E6                          1980  *       ADDI and ADDQ are used when the source is immediate data.
000024E6                          1981  *       Most assemblers automatically make this distinction.  
000024E6                          1982  
000024E6  31FC 0000 1008          1983  BRADD   MOVE.W  #$000,(IOOPCD)  Set OP-code name
000024EC  6100 FE86               1984          BSR     EXDST           Extract OP mode & register
000024F0  6100 FDA8               1985          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
000024F4                          1986          * "If the location specified is a source operand,
000024F4                          1987          * all addressing modes can be used [...]."
000024F4  B43C 0000               1988          CMP.B   #0,D2           Compare operation to Dn
000024F8  6604                    1989          BNE.S   *+6             If !=, skip next line
000024FA  303C 0FFF               1990          MOVE.W  #M_ALL,D0       Set all modes as valid
000024FE                          1991          * "If the location specified is a destination operand,
000024FE                          1992          * only memory alterable addressing modes can be used [...]."
000024FE  B43C 0001               1993          CMP.B   #1,D2           Compare operation to <ea>
00002502  6604                    1994          BNE.S   *+6             If !=, skip next line
00002504  303C 01FC               1995          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002508                          1996          * "ADDA is used when the destination is an address register."
00002508  B43C 0002               1997          CMP.B   #2,D2           Compare operation to An
0000250C  6700 0024               1998          BEQ     BRADDA          If ==, branch to BRADDA
00002510  6100 FCF6               1999          BSR     ADVBFR          Else, advance the buffer accordingly
00002514  6100 FE94               2000          BSR     EXSRC           Extract EA mode & register
00002518  6100 FCC6               2001          BSR     TSTAM           Test modes for validity
0000251C  6600 ED6E               2002          BNE     FLAGCL          If not valid, return unsuccessful
00002520  6100 FCE6               2003          BSR     ADVBFR          Else, advance the buffer accordingly
00002524  B43C 0001               2004          CMP.B   #1,D2           Compare operation to <ea>
00002528  6604                    2005          BNE     *+6             If !=, skip the next line
0000252A  6100 FEAC               2006          BSR     SWAPF           Else, swap the destination & source values
0000252E  6000 ED56               2007          BRA     FLAGST          Return successful
00002532                          2008  
00002532                          2009  
00002532                          2010  * ADDA: 1101|REG|OPM|EMD|ERG
00002532                          2011  * Syntax: ADDA      <ea>,An
00002532                          2012  
00002532  31FC 0004 1008          2013  BRADDA  MOVE.W  #$004,(IOOPCD)  Set OP-code name
00002538  0C38 0000 100C          2014          CMP.B   #0,(IOSIZE)     Compare size to byte
0000253E  6700 ED4C               2015          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002542  6100 FCC4               2016          BSR     ADVBFR          Else, advance the buffer accordingly
00002546  6100 FE62               2017          BSR     EXSRC           Extract source EA mode & register
0000254A                          2018          * Source EA field: "All addressing modes can be used [...]."
0000254A  303C 0FFF               2019          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
0000254E  6100 FC90               2020          BSR     TSTAM           Test modes for validity
00002552  6600 ED38               2021          BNE     FLAGCL          If not valid, return unsuccessful
00002556  6100 FCB0               2022          BSR     ADVBFR          Advance the buffer accordingly
0000255A  6000 ED2A               2023          BRA     FLAGST          Return successful
0000255E                          2024  
0000255E                          2025  * ADDQ: 0101|DAT|0|SZ|EMD|ERG
0000255E                          2026  * Syntax: ADDQ      #<1-8>,<ea>
0000255E                          2027  
0000255E  31FC 000E 1008          2028  BRADDQ  MOVE.W  #$00E,(IOOPCD)  Set OP-code name
00002564  6000 FE98               2029          BRA     BRARMQ          Branch to arithmetic Q instruction
00002568                          2030  
00002568                          2031  * SUB: 1001|REG|OPM|EMD|ERG
00002568                          2032  * Syntax: SUB       <ea>,Dn
00002568                          2033  *         SUB       Dn,<ea>
00002568                          2034  * Note: Most assemblers use SUBA when the destination is an address register
00002568                          2035  *       and SUBI or SUBQ when the source is immediate data.
00002568                          2036  
00002568  31FC 00F7 1008          2037  BRSUB   MOVE.W  #$0F7,(IOOPCD)  Set OP-code name
0000256E  6100 FE04               2038          BSR     EXDST           Extract OP mode & register
00002572  6100 FD26               2039          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002576                          2040          * "If the location specified is a source operand,
00002576                          2041          * all addressing modes can be used [...]."
00002576  B43C 0000               2042          CMP.B   #0,D2           Compare operation to Dn
0000257A  6604                    2043          BNE.S   *+6             If !=, skip next line
0000257C  303C 0FFF               2044          MOVE.W  #M_ALL,D0       Set all modes as valid
00002580                          2045          * "If the location specified is a destination operand,
00002580                          2046          * only memory alterable addressing modes can be used [...]."
00002580  B43C 0001               2047          CMP.B   #1,D2           Compare operation to <ea>
00002584  6604                    2048          BNE.S   *+6             If !=, skip next line
00002586  303C 01FC               2049          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
0000258A                          2050          * "SUBA is used when the destination is an address register."
0000258A  B43C 0002               2051          CMP.B   #2,D2           Compare operation to An
0000258E  6700 0024               2052          BEQ     BRSUBA          If ==, branch to BRADDA
00002592  6100 FC74               2053          BSR     ADVBFR          Else, advance the buffer accordingly
00002596  6100 FE12               2054          BSR     EXSRC           Extract EA mode & register
0000259A  6100 FC44               2055          BSR     TSTAM           Test modes for validity
0000259E  6600 ECEC               2056          BNE     FLAGCL          If not valid, return unsuccessful
000025A2  6100 FC64               2057          BSR     ADVBFR          Else, advance the buffer accordingly
000025A6  B43C 0001               2058          CMP.B   #1,D2           Compare operation to <ea>
000025AA  6604                    2059          BNE     *+6             If !=, skip the next line
000025AC  6100 FE2A               2060          BSR     SWAPF           Else, swap the destination & source values
000025B0  6000 ECD4               2061          BRA     FLAGST          Return successful
000025B4                          2062  
000025B4                          2063  
000025B4                          2064  * SUBA: 1001|REG|OPM|EMD|ERG
000025B4                          2065  * Syntax: SUBA      <ea>,An
000025B4                          2066  
000025B4  31FC 00FB 1008          2067  BRSUBA  MOVE.W  #$0FB,(IOOPCD)  Set OP-code name
000025BA  0C38 0000 100C          2068          CMP.B   #0,(IOSIZE)     Compare size to byte
000025C0  6700 ECCA               2069          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
000025C4  6100 FC42               2070          BSR     ADVBFR          Else, advance the buffer accordingly
000025C8                          2071          * "All addressing modes can be used [...]."
000025C8  303C 0FFF               2072          MOVE.W  #M_ALL,D0       Set all modes as valid
000025CC  6100 FDDC               2073          BSR     EXSRC           Extract EA mode & register
000025D0  6100 FC0E               2074          BSR     TSTAM           Test modes for validity
000025D4  6600 ECB6               2075          BNE     FLAGCL          If not valid, return unsuccessful
000025D8  6100 FC2E               2076          BSR     ADVBFR          Else, advance the buffer accordingly
000025DC  6000 ECA8               2077          BRA     FLAGST          Return successful
000025E0                          2078  
000025E0                          2079  * SUBQ: 0101|DAT|1|SZ|EMD|ERG
000025E0                          2080  * Syntax: SUBQ      #<1-8>,<ea>
000025E0  31FC 0105 1008          2081  BRSUBQ  MOVE.W  #$105,(IOOPCD)  Set OP-code name
000025E6  6000 FE16               2082          BRA     BRARMQ          Branch to arithmetic Q instruction
000025EA                          2083  
000025EA                          2084  * AND: 1100|REG|OPM|EMD|ERG
000025EA                          2085  * Syntax: AND       <ea>,Dn
000025EA                          2086  *         AND       Dn,<ea>
000025EA                          2087  * Note: The Dn mode is used when the destination is a data register;
000025EA                          2088  *       the destination < ea > mode is invalid for a data register. 
000025EA                          2089  *       Most assemblers use ANDI when the source is immediate data.
000025EA                          2090  
000025EA  31FC 0013 1008          2091  BRAND   MOVE.W  #$013,(IOOPCD)  Set OP-code name
000025F0  6100 FD82               2092          BSR     EXDST           Extract OP mode & register
000025F4  6100 FCA4               2093          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
000025F8  B43C 0002               2094          CMP.B   #2,D2           Compare OP mode to An
000025FC  6700 EC8E               2095          BEQ     FLAGCL          If ==, mode is not valid, return unsuccessful
00002600  6100 FC06               2096          BSR     ADVBFR          Else, advance the buffer accordingly
00002604                          2097          * "If the location specified is a source operand,
00002604                          2098          * only data addressing modes can be used [...]."
00002604  B43C 0000               2099          CMP.B   #0,D2           Compare operation to Dn
00002608  6604                    2100          BNE.S   *+6             If !=, skip next line
0000260A  303C 0FFD               2101          MOVE.W  #M_DAT,D0       Set data modes as valid
0000260E                          2102          * "If the location specified is a destination operand,
0000260E                          2103          * only memory alterable addressing modes can be used [...]."
0000260E  B43C 0001               2104          CMP.B   #1,D2           Compare operation to <ea>
00002612  6604                    2105          BNE.S   *+6             If !=, skip next line
00002614  303C 01FC               2106          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002618  6100 FD90               2107          BSR     EXSRC           Extract EA mode & register
0000261C  6100 FBC2               2108          BSR     TSTAM           Test modes for validity
00002620  6600 EC6A               2109          BNE     FLAGCL          If not valid, return unsuccessful
00002624  6100 FBE2               2110          BSR     ADVBFR          Else, advance the buffer accordingly
00002628  B43C 0001               2111          CMP.B   #1,D2           Compare operation to <ea>
0000262C  6604                    2112          BNE     *+6             If !=, skip the next line
0000262E  6100 FDA8               2113          BSR     SWAPF           Else, swap the destination & source values
00002632  6000 EC52               2114          BRA     FLAGST          Return successful
00002636                          2115  
00002636                          2116  * OR: 1000|REG|OPM|EMD|ERG
00002636                          2117  * Syntax: OR        <ea>,Dn
00002636                          2118  *         OR        Dn,<ea>
00002636                          2119  * Note: The Dn mode is used when the destination is a data register;
00002636                          2120  *       the destination < ea > mode is invalid for a data register. 
00002636                          2121  *       Most assemblers use ORI when the source is immediate data.
00002636                          2122  
00002636  31FC 00E4 1008          2123  BROR    MOVE.W  #$0E4,(IOOPCD)  Set OP-code name
0000263C  6100 FD36               2124          BSR     EXDST           Extract OP mode & register
00002640  6100 FC58               2125          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002644  B43C 0002               2126          CMP.B   #2,D2           Compare OP mode to An
00002648  6700 EC42               2127          BEQ     FLAGCL          If ==, mode is not valid, return unsuccessful
0000264C  6100 FBBA               2128          BSR     ADVBFR          Else, advance the buffer accordingly
00002650                          2129          * "If the location specified is a source operand,
00002650                          2130          * only data addressing modes can be used [...]."
00002650  B43C 0000               2131          CMP.B   #0,D2           Compare operation to Dn
00002654  6604                    2132          BNE.S   *+6             If !=, skip next line
00002656  303C 0FFD               2133          MOVE.W  #M_DAT,D0       Set data modes as valid
0000265A                          2134          * "If the location specified is a destination operand,
0000265A                          2135          * only memory alterable addressing modes can be used [...]."
0000265A  B43C 0001               2136          CMP.B   #1,D2           Compare operation to <ea>
0000265E  6604                    2137          BNE.S   *+6             If !=, skip next line
00002660  303C 01FC               2138          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002664  6100 FD44               2139          BSR     EXSRC           Extract EA mode & register
00002668  6100 FB76               2140          BSR     TSTAM           Test modes for validity
0000266C  6600 EC1E               2141          BNE     FLAGCL          If not valid, return unsuccessful
00002670  6100 FB96               2142          BSR     ADVBFR          Else, advance the buffer accordingly
00002674  B43C 0001               2143          CMP.B   #1,D2           Compare operation to <ea>
00002678  6604                    2144          BNE     *+6             If !=, skip the next line
0000267A  6100 FD5C               2145          BSR     SWAPF           Else, swap the destination & source values
0000267E  6000 EC06               2146          BRA     FLAGST          Return successful
00002682                          2147  
00002682                          2148  
00002682                          2149  * BTST: 0000XXXX00|EMD|ERG
00002682                          2150  * Syntax: BTST      Dn,<ea>
00002682                          2151  *         BTST      #<data>,<ea>
00002682                          2152  
00002682  31FC 0028 1008          2153  BRBTST  MOVE.W  #$028,(IOOPCD)  Set OP-code name
00002688  6100 FCEA               2154          BSR     EXDST           Extract bits in destination mode & register location
0000268C  0C38 0000 1158          2155          CMP.B   #0,(DMD)        Compare the mode to STATIC
00002692  6700 0010               2156          BEQ     BRBTSTS         If ==, branch to BTST STATIC
00002696  0C38 0004 1158          2157          CMP.B   #4,(DMD)        Compare the mode to DYNAMIC
0000269C  6700 0054               2158          BEQ     BRBTSTD         If ==, branch to BTST DYNAMIC
000026A0  6000 EBEA               2159          BRA     FLAGCL          If neither were found, return unsuccessful
000026A4                          2160  
000026A4                          2161  * BTST STATIC: 0000100000|EMD|ERG
000026A4                          2162  *              00000000|_BITNUM_
000026A4                          2163  * Syntax: BTST      #<data>,<ea>
000026A4                          2164  
000026A4  6100 FD04               2165  BRBTSTS BSR     EXSRC           Extract destination from source location
000026A8                          2166          * "Only data addressing modes can be used [...]."
000026A8                          2167          * M68 Manual oddly does not note that #<data> is invalid
000026A8  303C 07FD               2168          MOVE.W  #$7FD,D0        Set data modes - #<data> as valid %0000111111111101
000026AC  6100 FB32               2169          BSR     TSTAM           Test modes for validity
000026B0  6600 EBDA               2170          BNE     FLAGCL          If not valid, return unsuccessful
000026B4  6100 FD22               2171          BSR     SWAPF           Else, swap source to destination
000026B8  11FC 0000 100C          2172          MOVE.B  #0,(IOSIZE)     Set size to byte
000026BE  0C38 0000 1158          2173          CMP.B   #0,(DMD)        Compare destination to Dn
000026C4  6606                    2174          BNE     *+8             If !=, skip the next line
000026C6  11FC 0002 100C          2175          MOVE.B  #2,(IOSIZE)     Else, set size to long
000026CC  6100 FB3A               2176          BSR     ADVBFR          Advance buffer accordingly
000026D0  5489                    2177          ADD.L   #2,A1           Advance buffer for bit num
000026D2  11FC 0008 115A          2178          MOVE.B  #8,(SMD)        Set source mode to 3 BEARS CUSTOM
000026D8  11FC 0008 115B          2179          MOVE.B  #8,(SRG)        Set reg mode to 8 for #<bit num>.B
000026DE  0C38 0007 1158          2180          CMP.B   #%111,(DMD)     Compare destination mode to special
000026E4  6600 EBA0               2181          BNE     FLAGST          If !=, return successful
000026E8  11FC 0009 1158          2182          MOVE.B  #%1001,(DMD)    Else if ==, set mode to special-- next word
000026EE  6000 EB96               2183          BRA     FLAGST          Return successful
000026F2                          2184  
000026F2                          2185  * BTST DYNAMIC: 0000|REG|100|EMD|ERG
000026F2                          2186  * Syntax: BTST      Dn,<ea>
000026F2                          2187  
000026F2  6100 FCB6               2188  BRBTSTD BSR     EXSRC           Extract destination from source location
000026F6                          2189          * "Only data addressing modes can be used [...]."
000026F6  303C 0FFD               2190          MOVE.W  #M_DAT,D0       Set data modes as valid
000026FA  6100 FAE4               2191          BSR     TSTAM           Test modes for validity
000026FE  6600 EB8C               2192          BNE     FLAGCL          If not valid, return unsuccessful
00002702  6100 FCD4               2193          BSR     SWAPF           Else, swap source to destination
00002706  11FC 0000 100C          2194          MOVE.B  #0,(IOSIZE)     Set size to byte
0000270C  0C38 0000 1158          2195          CMP.B   #0,(DMD)        Compare destination to Dn
00002712  6606                    2196          BNE     *+8             If !=, skip the next line
00002714  11FC 0002 100C          2197          MOVE.B  #2,(IOSIZE)     Else, set size to long
0000271A  6100 FAEC               2198          BSR     ADVBFR          Advance buffer accordingly
0000271E  11FC 0000 115A          2199          MOVE.B  #0,(SMD)        Set source mode to Dn
00002724  6000 EB60               2200          BRA     FLAGST          Return successful
00002728                          2201  
00002728                          2202  * Bcc: 0110|COND|_8BTDSP_
00002728                          2203  * Syntax: Bcc       <label>
00002728                          2204  * Branch on...
00002728                          2205  *  BRA:     0000
00002728                          2206  *  BSR:     0001
00002728                          2207  *   HI:     0010
00002728                          2208  *   LS:     0011
00002728                          2209  *   CC(HI): 0100
00002728                          2210  *   CS(LO): 0101
00002728                          2211  *   NE:     0110
00002728                          2212  *   EQ:     0111
00002728                          2213  *   VC:     1000
00002728                          2214  *   VS:     1001
00002728                          2215  *   PL:     1010
00002728                          2216  *   MI:     1011
00002728                          2217  *   GE:     1100
00002728                          2218  *   LT:     1101
00002728                          2219  *   GT:     1110
00002728                          2220  *   LE:     1111
00002728                          2221  
00002728  3011                    2222  BRBccd  MOVE.W  (A1),D0         Move instruction to D0
0000272A  243C 000000FF           2223          MOVE.L  #$00FF,D2       Extract displacement at 0000000011111111
00002730  6100 ECC4               2224          BSR     EXTMSK          Get the displacement to D1
00002734  11FC 0008 1158          2225          MOVE.B  #8,(DMD)        Set mode to 3 BEARS CUSTOM
0000273A  11FC 0002 1159          2226          MOVE.B  #2,(DRG)        Set register to (DISP).Q
00002740  B23C 0000               2227          CMP.B   #$00,D1         $00 = 16 bit displacement
00002744  6608                    2228          BNE.S   *+10            If !=, skip next two lines
00002746  11FC 0004 1159          2229          MOVE.B  #4,(DRG)        Else, Set register to (DISP).W
0000274C  5489                    2230          ADD.L   #2,A1           Advance buffer by word
0000274E  B23C 00FF               2231          CMP.B   #$FF,D1         $FF = 32 bit displacement
00002752  6608                    2232          BNE.S   *+10            If !=, skip next two lines
00002754  11FC 0005 1159          2233          MOVE.B  #5,(DRG)        Else, Set register to (DISP).L
0000275A  5889                    2234          ADD.L   #4,A1           Advance buffer by long
0000275C  243C 00000F00           2235          MOVE.L  #$0F00,D2       Extract condition at  0000111100000000
00002762  4281                    2236          CLR.L   D1              Clear D1 for table displacement
00002764  6100 EC90               2237          BSR     EXTMSK          Get the condition to D1
00002768  C2FC 0004               2238          MULU.W  #4,D1           Convert condition to displacement
0000276C  4EFB 1002               2239          JMP     BccTBL(PC,D1)   Jump to condition code branch
00002770  6000 006A               2240  BccTBL  BRA     BRBRA
00002774  6000 0070               2241          BRA     BRBSR
00002778  6000 0058               2242          BRA     BRBHI
0000277C  6000 00CC               2243          BRA     BRBLS
00002780  6000 006E               2244          BRA     BRBCC
00002784  6000 0074               2245          BRA     BRBCS
00002788  6000 003E               2246          BRA     BRBNE
0000278C  6000 0026               2247          BRA     BRBEQ
00002790  6000 0072               2248          BRA     BRBVC
00002794  6000 0078               2249          BRA     BRBVS
00002798  6000 007E               2250          BRA     BRBPL
0000279C  6000 0084               2251          BRA     BRBMI
000027A0  6000 008A               2252          BRA     BRBGE
000027A4  6000 0018               2253          BRA     BRBLT
000027A8  6000 008C               2254          BRA     BRBGT
000027AC  6000 0092               2255          BRA     BRBLE
000027B0  6000 EADA               2256          BRA     FLAGCL          Return unsuccessful-- this should never happen
000027B4                          2257  
000027B4  31FC 004F 1008          2258  BRBEQ   MOVE.W  #$04F,(IOOPCD)  Set OP-code name
000027BA  6000 EACA               2259          BRA     FLAGST          Return successful
000027BE                          2260          
000027BE  31FC 006D 1008          2261  BRBLT   MOVE.W  #$06D,(IOOPCD)  Set OP-code name
000027C4  6000 EAC0               2262          BRA     FLAGST          Return successful
000027C8                          2263  
000027C8  31FC 0077 1008          2264  BRBNE   MOVE.W  #$077,(IOOPCD)  Set OP-code name
000027CE  6000 EAB6               2265          BRA     FLAGST          Return successful
000027D2                          2266  
000027D2  31FC 005E 1008          2267  BRBHI   MOVE.W  #$05E,(IOOPCD)  Set OP-code name
000027D8  6000 EAAC               2268          BRA     FLAGST          Return successful
000027DC                          2269  
000027DC  31FC 0081 1008          2270  BRBRA   MOVE.W  #$081,(IOOPCD)  Set OP-code name
000027E2  6000 EAA2               2271          BRA     FLAGST          Return successful
000027E6                          2272          
000027E6  31FC 0024 1008          2273  BRBSR   MOVE.W  #$024,(IOOPCD)  Set OP-code name
000027EC  6000 EA98               2274          BRA     FLAGST          Return successful
000027F0                          2275  
000027F0  31FC 0045 1008          2276  BRBCC   MOVE.W  #$045,(IOOPCD)  Set OP-code name
000027F6  6000 EA8E               2277          BRA     FLAGST          Return successful
000027FA                          2278  
000027FA  31FC 0050 1008          2279  BRBCS   MOVE.W  #$050,(IOOPCD)  Set OP-code name
00002800  6000 EA84               2280          BRA     FLAGST          Return successful
00002804                          2281  
00002804  31FC 0086 1008          2282  BRBVC   MOVE.W  #$086,(IOOPCD)  Set OP-code name
0000280A  6000 EA7A               2283          BRA     FLAGST          Return successful
0000280E                          2284  
0000280E  31FC 008B 1008          2285  BRBVS   MOVE.W  #$08B,(IOOPCD)  Set OP-code name
00002814  6000 EA70               2286          BRA     FLAGST          Return successful
00002818                          2287          
00002818  31FC 007C 1008          2288  BRBPL   MOVE.W  #$07C,(IOOPCD)  Set OP-code name
0000281E  6000 EA66               2289          BRA     FLAGST          Return successful
00002822                          2290  
00002822  31FC 0072 1008          2291  BRBMI   MOVE.W  #$072,(IOOPCD)  Set OP-code name
00002828  6000 EA5C               2292          BRA     FLAGST          Return successful
0000282C                          2293  
0000282C  31FC 0054 1008          2294  BRBGE   MOVE.W  #$054,(IOOPCD)  Set OP-code name
00002832  6000 EA52               2295          BRA     FLAGST          Return successful
00002836                          2296  
00002836  31FC 0059 1008          2297  BRBGT   MOVE.W  #$059,(IOOPCD)  Set OP-code name
0000283C  6000 EA48               2298          BRA     FLAGST          Return successful
00002840                          2299  
00002840  31FC 0063 1008          2300  BRBLE   MOVE.W  #$063,(IOOPCD)  Set OP-code name
00002846  6000 EA3E               2301          BRA     FLAGST          Return successful
0000284A                          2302  
0000284A  31FC 0068 1008          2303  BRBLS   MOVE.W  #$068,(IOOPCD)  Set OP-code name
00002850  6000 EA34               2304          BRA     FLAGST          Return successful
00002854                          2305  
00002854                          2306  * DBcc:0101|COND|11001|REG  ___16_BIT_DSP___
00002854                          2307  * Syntax: DBcc       Dn,<label>
00002854                          2308  * Branch on...
00002854                          2309  
00002854                          2310  *    T:     0000
00002854                          2311  *    F:     0001
00002854                          2312  *   HI:     0010
00002854                          2313  *   LS:     0011
00002854                          2314  *   CC:     0100
00002854                          2315  *   CS:     0101
00002854                          2316  *   NE:     0110
00002854                          2317  *   EQ:     0111
00002854                          2318  *   VC:     1000
00002854                          2319  *   VS:     1001
00002854                          2320  *   PL:     1010
00002854                          2321  *   MI:     1011
00002854                          2322  *   GE:     1100
00002854                          2323  *   LT:     1101
00002854                          2324  *   GT:     1110
00002854                          2325  *   LE:     1111
00002854                          2326  
00002854  3011                    2327  BRDBccd MOVE.W  (A1),D0         Move instruction to D0
00002856  6100 FB52               2328          BSR     EXSRC           Extract source mode & reg
0000285A  11FC 0000 115A          2329          MOVE.B  #0,(SMD)        Set mode to Dn
00002860  11FC 0008 1158          2330          MOVE.B  #8,(DMD)        Set mode to 3 BEARS CUSTOM
00002866  11FC 0004 1159          2331          MOVE.B  #4,(DRG)        Set register to (DISP).W
0000286C  11FC 0001 100C          2332          MOVE.B  #1,(IOSIZE)     Set size to word
00002872  243C 00000F00           2333          MOVE.L  #$0F00,D2       Extract condition at 0000111100000000
00002878  4281                    2334          CLR.L   D1              Clear D1 for table displacement
0000287A  6100 EB7A               2335          BSR     EXTMSK          Get the condition to D1
0000287E  5889                    2336          ADD.L   #4,A1           Advance buffer by long
00002880  C2FC 0004               2337          MULU.W  #4,D1           Convert condition to displacement
00002884  4EFB 1002               2338          JMP     DBccTBL(PC,D1)  Jump to condition code branch
00002888  6000 0042               2339  DBccTBL BRA     BRDBT
0000288C  6000 0048               2340          BRA     BRDBF
00002890  6000 004E               2341          BRA     BRDBHI
00002894  6000 0054               2342          BRA     BRDBLS
00002898  6000 005A               2343          BRA     BRDBCC
0000289C  6000 0060               2344          BRA     BRDBCS
000028A0  6000 0066               2345          BRA     BRDBNE
000028A4  6000 006C               2346          BRA     BRDBEQ
000028A8  6000 0072               2347          BRA     BRDBVC
000028AC  6000 0078               2348          BRA     BRDBVS
000028B0  6000 007E               2349          BRA     BRDBPL
000028B4  6000 0084               2350          BRA     BRDBMI
000028B8  6000 008A               2351          BRA     BRDBGE
000028BC  6000 0090               2352          BRA     BRDBLT
000028C0  6000 0096               2353          BRA     BRDBGT
000028C4  6000 009C               2354          BRA     BRDBLE
000028C8  6000 E9C2               2355          BRA     FLAGCL          Return unsuccessful-- this should never happen
000028CC                          2356  
000028CC                          2357  
000028CC  31FC 0114 1008          2358  BRDBT   MOVE.W  #$114,(IOOPCD)  Set OP-code name
000028D2  6000 E9B2               2359          BRA     FLAGST          Return successful
000028D6                          2360          
000028D6  31FC 0118 1008          2361  BRDBF   MOVE.W  #$118,(IOOPCD)  Set OP-code name
000028DC  6000 E9A8               2362          BRA     FLAGST          Return successful
000028E0                          2363  
000028E0  31FC 005D 1008          2364  BRDBHI  MOVE.W  #$05D,(IOOPCD)  Set OP-code name
000028E6  6000 E99E               2365          BRA     FLAGST          Return successful
000028EA                          2366  
000028EA  31FC 0067 1008          2367  BRDBLS  MOVE.W  #$067,(IOOPCD)  Set OP-code name
000028F0  6000 E994               2368          BRA     FLAGST          Return successful
000028F4                          2369  
000028F4  31FC 0044 1008          2370  BRDBCC  MOVE.W  #$044,(IOOPCD)  Set OP-code name
000028FA  6000 E98A               2371          BRA     FLAGST          Return successful
000028FE                          2372          
000028FE  31FC 0049 1008          2373  BRDBCS  MOVE.W  #$049,(IOOPCD)  Set OP-code name
00002904  6000 E980               2374          BRA     FLAGST          Return successful
00002908                          2375  
00002908  31FC 0076 1008          2376  BRDBNE  MOVE.W  #$076,(IOOPCD)  Set OP-code name
0000290E  6000 E976               2377          BRA     FLAGST          Return successful
00002912                          2378  
00002912  31FC 004E 1008          2379  BRDBEQ  MOVE.W  #$04E,(IOOPCD)  Set OP-code name
00002918  6000 E96C               2380          BRA     FLAGST          Return successful
0000291C                          2381  
0000291C  31FC 0085 1008          2382  BRDBVC  MOVE.W  #$085,(IOOPCD)  Set OP-code name
00002922  6000 E962               2383          BRA     FLAGST          Return successful
00002926                          2384  
00002926  31FC 008A 1008          2385  BRDBVS  MOVE.W  #$08A,(IOOPCD)  Set OP-code name
0000292C  6000 E958               2386          BRA     FLAGST          Return successful
00002930                          2387          
00002930  31FC 007B 1008          2388  BRDBPL  MOVE.W  #$07B,(IOOPCD)  Set OP-code name
00002936  6000 E94E               2389          BRA     FLAGST          Return successful
0000293A                          2390  
0000293A  31FC 0071 1008          2391  BRDBMI  MOVE.W  #$071,(IOOPCD)  Set OP-code name
00002940  6000 E944               2392          BRA     FLAGST          Return successful
00002944                          2393  
00002944  31FC 0053 1008          2394  BRDBGE  MOVE.W  #$053,(IOOPCD)  Set OP-code name
0000294A  6000 E93A               2395          BRA     FLAGST          Return successful
0000294E                          2396  
0000294E  31FC 006C 1008          2397  BRDBLT  MOVE.W  #$06C,(IOOPCD)  Set OP-code name
00002954  6000 E930               2398          BRA     FLAGST          Return successful
00002958                          2399  
00002958  31FC 0058 1008          2400  BRDBGT  MOVE.W  #$058,(IOOPCD)  Set OP-code name
0000295E  6000 E926               2401          BRA     FLAGST          Return successful
00002962                          2402  
00002962  31FC 0062 1008          2403  BRDBLE  MOVE.W  #$062,(IOOPCD)  Set OP-code name
00002968  6000 E91C               2404          BRA     FLAGST          Return successful
0000296C                          2405  
0000296C                          2406  * CMP: 1011|REG|OPM|EMD|ERG
0000296C                          2407  * Syntax: CMP       <ea>,Dn
0000296C                          2408  * Note: CMPA is used when the destination is an address register.
0000296C                          2409  *       CMPI is used when the source is immediate data.
0000296C                          2410  *       CMPM is used for memory-to-memory compares.
0000296C                          2411  *       Most assemblers automatically make the distinction.
0000296C                          2412  
0000296C  31FC 0031 1008          2413  BRCMP   MOVE.W  #$031,(IOOPCD)  Set OP-code name
00002972  6100 FA00               2414          BSR     EXDST           Extract OP mode & register
00002976  6100 F922               2415          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
0000297A  B43C 0001               2416          CMP.B   #1,D2           Compare OP mode to <ea>
0000297E  6700 E90C               2417          BEQ     FLAGCL          If ==, it is invalid, branch to flag clear
00002982  B43C 0002               2418          CMP.B   #2,D2           Compare OP mode to An
00002986  6700 001E               2419          BEQ     BRCMPA          If ==, branch to BRCMPA
0000298A  6100 F87C               2420          BSR     ADVBFR          Else, advance the buffer acco\rdingly
0000298E  6100 FA1A               2421          BSR     EXSRC           Extract source mode & register
00002992                          2422          * Source EA field: "All addressing modes can be used [...]."
00002992  303C 0FFF               2423          MOVE.W  #M_ALL,D0       Set all modes as valid
00002996  6100 F848               2424          BSR     TSTAM           Test modes for validity
0000299A  6600 E8F0               2425          BNE     FLAGCL          If not valid, return unsuccessful
0000299E  6100 F868               2426          BSR     ADVBFR          Else, advance the buffer accordingly
000029A2  6000 E8E2               2427          BRA     FLAGST          Return successful
000029A6                          2428  
000029A6                          2429  * CMPA: 1011|REG|OPM|EMD|ERG
000029A6                          2430  * Syntax: CMPA      <ea>,An
000029A6                          2431  
000029A6  31FC 0035 1008          2432  BRCMPA  MOVE.W  #$035,(IOOPCD)  Set OP-code name
000029AC  0C38 0000 100C          2433          CMP.B   #0,(IOSIZE)     Compare size to byte
000029B2  6700 E8D8               2434          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
000029B6  6100 F850               2435          BSR     ADVBFR          Else, advance the buffer accordingly
000029BA  6100 F9EE               2436          BSR     EXSRC           Extract source EA mode & register
000029BE                          2437          * Source EA field: "All addressing modes can be used [...]."
000029BE  303C 0FFF               2438          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
000029C2  6100 F81C               2439          BSR     TSTAM           Test modes for validity
000029C6  6600 E8C4               2440          BNE     FLAGCL          If not valid, return unsuccessful
000029CA  6100 F83C               2441          BSR     ADVBFR          Else, advance the buffer accordingly
000029CE  6000 E8B6               2442          BRA     FLAGST          Return successful
000029D2                          2443  
000029D2                          2444  * EOR: 1011|REG|OPM|EMD|ERG
000029D2                          2445  * Syntax: EOR       Dn,<ea>
000029D2                          2446  * Note: Memory-to-data-register operations are not allowed.
000029D2                          2447  *       Most assemblers use EORI when the source is immediate data.
000029D2                          2448  
000029D2  31FC 0099 1008          2449  BREOR   MOVE.W  #$099,(IOOPCD)  Set OP-code name
000029D8  6100 F99A               2450          BSR     EXDST           Extract OP mode & register
000029DC  6100 F8BC               2451          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
000029E0  B43C 0001               2452          CMP.B   #1,D2           Compare OP mode to <ea>
000029E4  6600 E8A6               2453          BNE     FLAGCL          If !=, it is invalid, branch to flag clear
000029E8  6100 F81E               2454          BSR     ADVBFR          Else, advance the buffer accordingly
000029EC  6100 F9BC               2455          BSR     EXSRC           Extract source mode & register
000029F0                          2456          * Source EA field: "Only data alterable modes can be used [...]."
000029F0  303C 01FD               2457          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
000029F4  6100 F7EA               2458          BSR     TSTAM           Test modes for validity
000029F8  6600 E892               2459          BNE     FLAGCL          If not valid, return unsuccessful
000029FC  6100 F80A               2460          BSR     ADVBFR          Else, advance the buffer accordingly
00002A00  6100 F9D6               2461          BSR     SWAPF           Swap dest & source fields
00002A04  6000 E880               2462          BRA     FLAGST          Return successful
00002A08                          2463  
00002A08                          2464  * LEA: 0100|REG|111|EMD|ERG
00002A08                          2465  * Syntax: LEA       <ea>,An
00002A08                          2466  
00002A08  31FC 00AA 1008          2467  BRLEA   MOVE.W  #$0AA,(IOOPCD)  Set OP-code name
00002A0E  6100 F964               2468          BSR     EXDST           Extract destination mode & register
00002A12  11FC 0001 1158          2469          MOVE.B  #%001,(DMD)     Set destination mode to An
00002A18  6100 F990               2470          BSR     EXSRC           Extract source mode & register
00002A1C                          2471          * "Source EA field: "Only control addressing modes can be used [...]."
00002A1C  303C 07E4               2472          MOVE.W  #M_CTR,D0       Set control modes as valid
00002A20  6100 F7BE               2473          BSR     TSTAM           Test modes for validity
00002A24  6600 E866               2474          BNE     FLAGCL          If not valid, return unsuccessful
00002A28  6100 F7DE               2475          BSR     ADVBFR          Else, advance the buffer accordingly
00002A2C  6000 E858               2476          BRA     FLAGST          Return successful
00002A30                          2477  
00002A30                          2478  * JSR: 0100111010|EMD|ERG
00002A30                          2479  * Syntax: JSR       <ea>
00002A30                          2480  
00002A30  31FC 00A6 1008          2481  BRJSR   MOVE.W  #$0A6,(IOOPCD)  Set OP-code name
00002A36  6100 F972               2482          BSR     EXSRC           Extract source mode & register
00002A3A                          2483          * "Source EA field: "Only control addressing modes can be used [...]."
00002A3A  303C 07E4               2484          MOVE.W  #M_CTR,D0       Set control modes as valid
00002A3E  6100 F7A0               2485          BSR     TSTAM           Test modes for validity
00002A42  6600 E848               2486          BNE     FLAGCL          If not valid, return unsuccessful
00002A46  6100 F7C0               2487          BSR     ADVBFR          Else, advance the buffer accordingly
00002A4A  6000 E83A               2488          BRA     FLAGST          Return successful
00002A4E                          2489  
00002A4E                          2490  * JMP: 0100111011|EMD|ERG
00002A4E                          2491  * Syntax: JMP       <ea>
00002A4E                          2492  
00002A4E  31FC 00A2 1008          2493  BRJMP   MOVE.W  #$0A2,(IOOPCD)  Set OP-code name
00002A54  6100 F954               2494          BSR     EXSRC           Extract source mode & register
00002A58                          2495          * "Source EA field: "Only control addressing modes can be used [...]."
00002A58  303C 07E4               2496          MOVE.W  #M_CTR,D0       Set control modes as valid
00002A5C  6100 F782               2497          BSR     TSTAM           Test modes for validity
00002A60  6600 E82A               2498          BNE     FLAGCL          If not valid, return unsuccessful
00002A64  6100 F7A2               2499          BSR     ADVBFR          Else, advance the buffer accordingly
00002A68  6000 E81C               2500          BRA     FLAGST          Return successful
00002A6C                          2501          
00002A6C                          2502  * MOVE: 00|SZ|DRG|DMD|SMD|SRG
00002A6C                          2503  * Syntax: MOVE      <ea>,<ea>
00002A6C                          2504  * Note: Most assemblers use MOVEA when the destination is an address register. 
00002A6C                          2505  *       MOVEQ can be used to move an immediate 8-bit value to a data register. 
00002A6C                          2506  
00002A6C  31FC 00B6 1008          2507  BRMOVE  MOVE.W  #$0B6,(IOOPCD)  Set OP-code name
00002A72  3011                    2508          MOVE.W  (A1),D0         Move instruction to D0
00002A74  243C 00003000           2509          MOVE.L  #$3000,D2       Extract size at 0011000000000000
00002A7A  6100 E97A               2510          BSR     EXTMSK          Get the size to D1
00002A7E                          2511  
00002A7E  103C 00FF               2512          MOVE.B  #$FF,D0         Set size to null
00002A82  B23C 0001               2513          CMP.B   #%01,D1         01 = Byte
00002A86  6604                    2514          BNE.S   *+6             Branch to next test
00002A88  103C 0000               2515          MOVE.B  #$0,D0          Set size to byte
00002A8C  B23C 0003               2516          CMP.B   #%11,D1         11 = Word
00002A90  6604                    2517          BNE.S   *+6             Branch to next test
00002A92  103C 0001               2518          MOVE.B  #$1,D0          Set size to word
00002A96  B23C 0002               2519          CMP.B   #%10,D1         10 = Long
00002A9A  6604                    2520          BNE.S   *+6             Branch to next test
00002A9C  103C 0002               2521          MOVE.B  #$2,D0          Set size to long
00002AA0  B03C 00FF               2522          CMP.B   #$FF,D0         Test if size was found
00002AA4  6700 E7E6               2523          BEQ     FLAGCL          If it was not found, branch to clear flag      
00002AA8  11C0 100C               2524          MOVE.B  D0,(IOSIZE)     If it was found, store size in IOSIZE
00002AAC                          2525  
00002AAC  6100 F8C6               2526          BSR     EXDST           Extract dest EA mode & register
00002AB0  0C38 0001 1158          2527          CMP.B   #1,(DMD)        Compare mode to An
00002AB6  6700 008E               2528          BEQ     BRMOVEA         If ==, branch to BRMOVEA
00002ABA                          2529          * Dest EA field: "Only data alterable addressing modes can be used [...]."
00002ABA  303C 01FD               2530          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002ABE  6100 F720               2531          BSR     TSTAM           Test modes for validity
00002AC2  6600 E7C8               2532          BNE     FLAGCL          If not valid, return unsuccessful
00002AC6  6100 F740               2533          BSR     ADVBFR          Else, advance the buffer accordingly
00002ACA  6100 F8DE               2534          BSR     EXSRC           Extract source EA mode & register
00002ACE                          2535          * Source EA field: "All addressing modes can be used [...]."
00002ACE  303C 0FFF               2536          MOVE.W  #M_ALL,D0       Set all modes as valid
00002AD2  6100 F70C               2537          BSR     TSTAM           Test modes for validity
00002AD6  6600 E7B4               2538          BNE     FLAGCL          If not valid, return unsuccessful
00002ADA  6100 F72C               2539          BSR     ADVBFR          Else, advance the buffer accordingly
00002ADE  6000 E7A6               2540          BRA     FLAGST          Return successful
00002AE2                          2541  
00002AE2                          2542  * MOVE from CCR: 0100001011|EMD|ERG
00002AE2                          2543  * Syntax: MOVE      CCR,<ea>
00002AE2                          2544  
00002AE2  31FC 00B6 1008          2545  BRMFCCR MOVE.W  #$0B6,(IOOPCD)  Set OP-code name
00002AE8  11FC 0001 100C          2546          MOVE.B  #1,(IOSIZE)     Set size to word
00002AEE  6100 F8BA               2547          BSR     EXSRC           Extract source EA mode & register
00002AF2                          2548          * "Only data alterable addressing modes can be used"
00002AF2  303C 01FD               2549          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002AF6  6100 F6E8               2550          BSR     TSTAM           Test modes for validity
00002AFA  6600 E790               2551          BNE     FLAGCL          If not valid, return unsuccessful
00002AFE  6100 F708               2552          BSR     ADVBFR          Else, advance the buffer accordingly
00002B02  11FC 0007 1158          2553          MOVE.B  #7,(DMD)        Set destination mode to special
00002B08  11FC 0005 1159          2554          MOVE.B  #5,(DRG)        Set destination mode to CCR
00002B0E  6100 F8C8               2555          BSR     SWAPF           Swap source and destination
00002B12  6000 E772               2556          BRA     FLAGST          Return successful
00002B16                          2557  
00002B16                          2558  * MOVE to CCR: 0100010011|EMD|ERG
00002B16                          2559  * Syntax: MOVE      <ea>,CCR
00002B16                          2560  
00002B16  31FC 00B6 1008          2561  BRMTCCR MOVE.W  #$0B6,(IOOPCD)  Set OP-code name
00002B1C  11FC 0001 100C          2562          MOVE.B  #1,(IOSIZE)     Set size to word
00002B22  6100 F886               2563          BSR     EXSRC           Extract source EA mode & register
00002B26                          2564          * "Only data addressing modes can be used"
00002B26  303C 0FFD               2565          MOVE.W  #M_DAT,D0       Set data modes as valid
00002B2A  6100 F6B4               2566          BSR     TSTAM           Test modes for validity
00002B2E  6600 E75C               2567          BNE     FLAGCL          If not valid, return unsuccessful
00002B32  6100 F6D4               2568          BSR     ADVBFR          Else, advance the buffer accordingly
00002B36  11FC 0007 1158          2569          MOVE.B  #7,(DMD)        Set destination mode to special
00002B3C  11FC 0005 1159          2570          MOVE.B  #5,(DRG)        Set destination mode to CCR
00002B42  6000 E742               2571          BRA     FLAGST          Return successful
00002B46                          2572  
00002B46                          2573  
00002B46                          2574  
00002B46                          2575  * MOVEA: 00|SZ|DRG|001|SMD|SRG
00002B46                          2576  * Syntax: MOVEA     <ea>,An
00002B46                          2577  
00002B46  31FC 00BB 1008          2578  BRMOVEA MOVE.W  #$0BB,(IOOPCD)  Set Op-code name
00002B4C  0C38 0000 100C          2579          CMP.B   #0,(IOSIZE)     Compare size to byte
00002B52  6700 E738               2580          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002B56  6100 F6B0               2581          BSR     ADVBFR          Else, advance the buffer accordingly
00002B5A  6100 F84E               2582          BSR     EXSRC           Extract source EA mode & register
00002B5E                          2583          * Source EA field: "All addressing modes can be used [...]."
00002B5E  303C 0FFF               2584          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002B62  6100 F67C               2585          BSR     TSTAM           Test modes for validity
00002B66  6600 E724               2586          BNE     FLAGCL          If not valid, return unsuccessful
00002B6A  6100 F69C               2587          BSR     ADVBFR          Else advance the buffer accordingly
00002B6E  6000 E716               2588          BRA     FLAGST          Return successful
00002B72                          2589  
00002B72                          2590  * MOVEM: 01001|D|001|S|EMD|ERG  REGISTERLISTMASK
00002B72                          2591  * Syntax: MOVEM     <list>,<ea>
00002B72                          2592  *         MOVEM     <ea>,<list>
00002B72                          2593  
00002B72  31FC 00C1 1008          2594  BRMOVEM MOVE.W  #$0C1,(IOOPCD)  Set OP-code name
00002B78  3011                    2595          MOVE.W  (A1),D0         Move instruction to D0
00002B7A  7440                    2596          MOVE.L  #$40,D2         Extract size at 0000000001000000
00002B7C  6100 E878               2597          BSR     EXTMSK          Get the size to D1
00002B80  5201                    2598          ADD.B   #1,D1           Convert size to W/L
00002B82  11C1 100C               2599          MOVE.B  D1,(IOSIZE)     Store D1 in size
00002B86  243C 00000400           2600          MOVE.L  #$0400,D2       Extract direction at 0000010000000000
00002B8C  6100 E868               2601          BSR     EXTMSK          Get the direction to D1
00002B90  1401                    2602          MOVE.B  D1,D2           Move direction to D2
00002B92                          2603          * Direction 0 = Register-to-memory
00002B92                          2604          * Direction 1 = Memory-to-register
00002B92  6100 F816               2605          BSR     EXSRC           Get the EA mode & reg from source location
00002B96                          2606          * EA field: "For register-to-memory transfers,
00002B96                          2607          * only control alterable addressing modes
00002B96                          2608          * or the predecrement addressing mode can be used [...]."
00002B96  303C 01F4               2609          MOVE.W  #$1F4,D0        Set valid modes for reg-to-mem by default (0000000111110100)
00002B9A  B43C 0000               2610          CMP.B   #0,D2           Compare direction to reg-to-mem
00002B9E  6704                    2611          BEQ.S   *+6             If ==, skip the next line
00002BA0                          2612          * EA field: "For memory-to-register transfers,
00002BA0                          2613          * only control addressing modes
00002BA0                          2614          * or the postincrement addressing mode can be used [...]."
00002BA0  303C 07EC               2615          MOVE.W  #$7EC,D0        Else, Set valid modes for mem-to-reg (0000011111101100)
00002BA4  6100 F63A               2616          BSR     TSTAM           Test modes for validity
00002BA8  6600 E6E2               2617          BNE     FLAGCL          If not valid, return unsuccessful
00002BAC  6100 F65A               2618          BSR     ADVBFR          Else advance the buffer accordingly, store displacement in EA
00002BB0  11FC 0008 1158          2619          MOVE.B  #8,(DMD)        Set mode to 3 BEARS CUSTOM
00002BB6  11FC 0006 1159          2620          MOVE.B  #6,(DRG)        Set register to (RLM).W by default
00002BBC                          2621          * "For the predecrement mode addresses, the mask correspondence is reversed."
00002BBC  0C38 0004 115A          2622          CMP.B   #%100,(SMD)     Compare source mode to predecrement mode
00002BC2  6606                    2623          BNE.S   *+8             If !=, skip next line
00002BC4  11FC 0007 1159          2624          MOVE.B  #7,(DRG)        Else if ==, set register to (MLR).W
00002BCA  0C38 0007 115A          2625          CMP.B   #7,(SMD)        Compare source mode to special
00002BD0  6606                    2626          BNE.S   *+8             If !=, skip next line
00002BD2  11FC 0009 115A          2627          MOVE.B  #9,(SMD)        Else if ==, set mode to special-- next word
00002BD8  5489                    2628          ADD.L   #2,A1           Advance buffer by word for RLM
00002BDA  6100 F7FC               2629          BSR     SWAPF           Swap the source and dest values
00002BDE  B43C 0000               2630          CMP.B   #0,D2           Compare direction to reg-to-mem
00002BE2  6700 E6A2               2631          BEQ     FLAGST          If ==, return successful
00002BE6  6100 F7F0               2632          BSR     SWAPF           Else, swap back values
00002BEA  1038 115D               2633          MOVE.B  (DIS),D0        Get displacement of EA in D0
00002BEE  B03C 0000               2634          CMP.B   #0,D0           Compare displacement to 0
00002BF2  6700 E692               2635          BEQ     FLAGST          If ==, return successful
00002BF6  11FC 000B 1158          2636          MOVE.B  #$B,(DMD)       Else, set mode to 3B special-- previous word
00002BFC  B03C 0002               2637          CMP.B   #2,D0           Compare displacement to 4
00002C00  6700 E684               2638          BEQ     FLAGST          If ==, return successful
00002C04  11FC 000C 1158          2639          MOVE.B  #$C,(DMD)       Else, set mode to 3B special-- previous long        
00002C0A  6000 E67A               2640          BRA     FLAGST          Return successful
00002C0E                          2641  
00002C0E                          2642  * MOVEQ: 0111|REG|0|__DATA__
00002C0E                          2643  * Syntax: MOVEQ     #<data>,Dn
00002C0E                          2644  
00002C0E  31FC 00C7 1008          2645  BRMOVEQ MOVE.W  #$0C7,(IOOPCD)  Set OP-code name
00002C14  6100 F75E               2646          BSR     EXDST           Extract destination
00002C18  11FC 0000 1158          2647          MOVE.B  #0,(DMD)        Set destination mode to Dn
00002C1E  11FC 0008 115A          2648          MOVE.B  #8,(SMD)        Set source mode to 3 BEARS CUSTOM
00002C24  11FC 0001 115B          2649          MOVE.B  #1,(SRG)        Set reg mode to 1 for #<data>.Q
00002C2A  11FC 0002 100C          2650          MOVE.B  #2,(IOSIZE)     Set size to long
00002C30  6000 E654               2651          BRA     FLAGST          Return successful
00002C34                          2652  
00002C34                          2653  * ROd: 1110011|d|11|EMD|ERG (memory rotate)
00002C34                          2654  *      1110|CRG|d|SZ|i|11|REG (register rotate)
00002C34                          2655  * Syntax: ROd       Dx,Dy
00002C34                          2656  *         ROd       #<data>,Dy
00002C34                          2657  *         Rod       <ea>
00002C34                          2658  
00002C34  3011                    2659  BRROd   MOVE.W  (A1),D0         Move instruction to D0
00002C36  31FC 00E3 1008          2660          MOVE.W  #$0E3,(IOOPCD)   Set OP-code name to ROR
00002C3C  7408                    2661          MOVE.L  #$8,D2          Extract direction at 0000000100000000
00002C3E  6100 E7B6               2662          BSR     EXTMSK          Get the direction to D1
00002C42  B23C 0000               2663          CMP.B   #0,D1           Compare direction to 0
00002C46  6608                    2664          BNE     *+10            If ==, skip the next line
00002C48  31FC 00DF 1008          2665          MOVE.W  #$0DF,(IOOPCD)  Else, set OP-code name to ROL
00002C4E                          2666  
00002C4E  243C 000000C0           2667          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002C54  6100 E7A0               2668          BSR     EXTMSK          Get the size to D1
00002C58  B23C 0003               2669          CMP.B   #%11,D1         Compare size to 11
00002C5C  6700 00CA               2670          BEQ     BRMAd           If ==, branch to memory alteration
00002C60  6000 0062               2671          BRA     BRRAd           Else, branch to register alteration
00002C64                          2672  
00002C64                          2673  
00002C64                          2674  
00002C64                          2675  * ASd: 1110000|d|11|EMD|ERG (memory shifts)
00002C64                          2676  *      1110|CRG|d|SZ|i|00|REG (register shifts)
00002C64                          2677  * Syntax: ASd       Dx,Dy
00002C64                          2678  *         ASd       #<data>,Dy
00002C64                          2679  *         ASd       <ea>
00002C64                          2680  
00002C64  3011                    2681  BRASd   MOVE.W  (A1),D0         Move instruction to D0
00002C66  31FC 0020 1008          2682          MOVE.W  #$020,(IOOPCD)  Set OP-code name to ASR
00002C6C  7408                    2683          MOVE.L  #$8,D2          Extract direction at 0000000100000000
00002C6E  6100 E786               2684          BSR     EXTMSK          Get the direction to D1
00002C72  B23C 0000               2685          CMP.B   #0,D1           Compare direction to 0
00002C76  6608                    2686          BNE     *+10            If ==, skip the next line
00002C78  31FC 001C 1008          2687          MOVE.W  #$01C,(IOOPCD)  Else, set OP-code name to ASL
00002C7E                          2688  
00002C7E  243C 000000C0           2689          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002C84  6100 E770               2690          BSR     EXTMSK          Get the size to D1
00002C88  B23C 0003               2691          CMP.B   #%11,D1         Compare size to 11
00002C8C  6700 009A               2692          BEQ     BRMAd           If ==, branch to memory alteration
00002C90  6000 0032               2693          BRA     BRRAd           Else, branch to register alteration
00002C94                          2694  
00002C94                          2695  * LSd: 1110001|d|11|EMD|ERG (memory shifts)
00002C94                          2696  *      1110|CRG|d|SZ|i|01|REG (register shifts)
00002C94                          2697  * Syntax: LSd       Dx,Dy
00002C94                          2698  *         LSd       #<data>,Dy
00002C94                          2699  *         LSd       <ea>
00002C94                          2700  
00002C94  3011                    2701  BRLSd   MOVE.W  (A1),D0         Move instruction to D0
00002C96  31FC 00B2 1008          2702          MOVE.W  #$0B2,(IOOPCD)  Set OP-code name to LSR
00002C9C  7408                    2703          MOVE.L  #$8,D2          Extract direction at 0000000100000000
00002C9E  6100 E756               2704          BSR     EXTMSK          Get the direction to D1
00002CA2  B23C 0000               2705          CMP.B   #0,D1           Compare direction to 0
00002CA6  6608                    2706          BNE     *+10            If ==, skip the next line
00002CA8  31FC 00AE 1008          2707          MOVE.W  #$0AE,(IOOPCD)  Else, set OP-code name to LSL
00002CAE                          2708  
00002CAE  243C 000000C0           2709          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002CB4  6100 E740               2710          BSR     EXTMSK          Get the size to D1
00002CB8  B23C 0003               2711          CMP.B   #%11,D1         Compare size to 11
00002CBC  6700 006A               2712          BEQ     BRMAd           If ==, branch to memory alteration
00002CC0  6000 0002               2713          BRA     BRRAd           Else, branch to register alteration
00002CC4                          2714  
00002CC4                          2715  * RAd: 1110|CRG|d|SZ|i|01|REG
00002CC4                          2716  * Syntax: RAd       Dx,Dy
00002CC4                          2717  *         RAd       #<data>,Dy
00002CC4                          2718  
00002CC4  B23C 0000               2719  BRRAd   CMP.B   #%00,D1         01 = Byte
00002CC8  6604                    2720          BNE.S   *+6             If !=, branch to next line
00002CCA  143C 0000               2721          MOVE.B  #$0,D2          Else, set size to byte
00002CCE  B23C 0001               2722          CMP.B   #%01,D1         11 = Word
00002CD2  6604                    2723          BNE.S   *+6             If !=, branch to next line
00002CD4  143C 0001               2724          MOVE.B  #$1,D2          Else, set size to word
00002CD8  B23C 0002               2725          CMP.B   #%10,D1         10 = Long
00002CDC  6604                    2726          BNE.S   *+6             If !=, Branch to next line
00002CDE  143C 0002               2727          MOVE.B  #$2,D2          Else, set size to long
00002CE2  11C2 100C               2728          MOVE.B  D2,(IOSIZE)     Move size to IOSIZE
00002CE6  7407                    2729          MOVE.L  #$0007,D2       Extract register at 0000000000000111
00002CE8  6100 E70C               2730          BSR     EXTMSK          Get the reg to D1
00002CEC  11C1 1159               2731          MOVE.B  D1,(DRG)        Store the reg in the destination register
00002CF0  11FC 0000 1158          2732          MOVE.B  #$0,(DMD)       Set the destination mode to Dn
00002CF6  11FC 0008 115A          2733          MOVE.B  #8,(SMD)        Set source mode to 3 BEARS CUSTOM
00002CFC  11FC 0000 115B          2734          MOVE.B  #0,(SRG)        Set reg mode to 0 for #<1-8>
00002D02  7420                    2735          MOVE.L  #$0020,D2       Extract i/r at 0000000000100000
00002D04  6100 E6F0               2736          BSR     EXTMSK          Get the i/r to D1
00002D08  B23C 0000               2737          CMP.B   #0,D1           Compare i/r to 0
00002D0C  6700 E578               2738          BEQ     FLAGST          If ==, branch to set flag
00002D10  243C 00000E00           2739          MOVE.L  #$0E00,D2       Else, extract reg at 0000111000000000
00002D16  6100 E6DE               2740          BSR     EXTMSK          Get the reg to D1
00002D1A  11C1 115B               2741          MOVE.B  D1,(SRG)        Store the reg in the source register
00002D1E  11FC 0000 115A          2742          MOVE.B  #0,(SMD)        Set source mode to Dn
00002D24  6000 E560               2743          BRA     FLAGST          Branch to flag set
00002D28                          2744  
00002D28                          2745  * MAd: 111000X|d|11|EMD|ERG
00002D28                          2746  * Syntax: MAd       <ea>
00002D28                          2747  
00002D28  11FC 0001 100C          2748  BRMAd   MOVE.B  #$1,(IOSIZE)    Set size to word
00002D2E                          2749          * EA field: "Only memory alterable addressing modes can be used [...]."
00002D2E  303C 01FC               2750          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002D32  6100 F676               2751          BSR     EXSRC           Extract destination from source location
00002D36  6100 F6A0               2752          BSR     SWAPF           Swap destination and source values
00002D3A  6100 F4A4               2753          BSR     TSTAM           Test modes for validity
00002D3E  6600 E54C               2754          BNE     FLAGCL          If invalid, return unsuccessful
00002D42  6100 F4C4               2755          BSR     ADVBFR          Else, advance the buffer accordingly
00002D46  6000 E53E               2756          BRA     FLAGST          Branch to set flag
00002D4A                          2757  
00002D4A                          2758  * MULU: 1100|REG|011|EMD|ERG
00002D4A                          2759  * Syntax: MULU.W    <ea>,Dn    16x16 -> 32
00002D4A                          2760  
00002D4A  31FC 00D2 1008          2761  BRMULU  MOVE.W  #$0D2,(IOOPCD)  Set OP-code name
00002D50  3011                    2762          MOVE.W  (A1),D0         Move instruction to D0
00002D52  6100 F620               2763          BSR     EXDST           Extract values in destination location
00002D56  6000 0032               2764          BRA     BRARW           Branch to arithmetic word instruction
00002D5A                          2765  
00002D5A                          2766  * MULS: 1100|REG|111|EMD|ERG
00002D5A                          2767  * Syntax: MULS.W    <ea>,Dn    16x16 -> 32
00002D5A                          2768  
00002D5A  31FC 00CD 1008          2769  BRMULS  MOVE.W  #$0CD,(IOOPCD)  Set OP-code name
00002D60  3011                    2770          MOVE.W  (A1),D0         Move instruction to D0
00002D62  6100 F610               2771          BSR     EXDST           Extract values in destination location
00002D66  6000 0022               2772          BRA     BRARW           Branch to arithmetic word instruction
00002D6A                          2773  
00002D6A                          2774  * DIVU: 1000|REG|011|EMD|ERG
00002D6A                          2775  * Synax: DIVU.W     <ea>,Dn     32/16 -> 16r-16q
00002D6A                          2776  
00002D6A  31FC 0094 1008          2777  BRDIVU  MOVE.W  #$094,(IOOPCD)  Set OP-code name     
00002D70  3011                    2778          MOVE.W  (A1),D0         Move instruction to D0
00002D72  6100 F600               2779          BSR     EXDST           Extract values in destination location
00002D76  6000 0012               2780          BRA     BRARW           Branch to arithmetic word instruction
00002D7A                          2781  
00002D7A                          2782  * DIVS: 1000|REG|111|EMD|ERG
00002D7A                          2783  * Synax: DIVS.W     <ea>,Dn     32/16 -> 16r-16q
00002D7A                          2784  
00002D7A  31FC 008F 1008          2785  BRDIVS  MOVE.W  #$08F,(IOOPCD)  Set OP-code name     
00002D80  3011                    2786          MOVE.W  (A1),D0         Move instruction to D0
00002D82  6100 F5F0               2787          BSR     EXDST           Extract values in destination location
00002D86  6000 0002               2788          BRA     BRARW           Branch to arithmetic word instruction
00002D8A                          2789  
00002D8A                          2790  * ARW: XX00|REG|X11|EMD|ERG
00002D8A                          2791  * Syntax: ARW       <ea>,Dn    16x16 -> 32
00002D8A                          2792  
00002D8A  11FC 0001 100C          2793  BRARW   MOVE.B  #$1,(IOSIZE)    Set size to word
00002D90  11FC 0000 1158          2794          MOVE.B  #$0,(DMD)       Set destination mode to Dn
00002D96                          2795          * EA field: "Only data addressing modes can be used [...]."
00002D96  303C 0FFD               2796          MOVE.W  #M_DAT,D0       Set data modes as valid
00002D9A  6100 F60E               2797          BSR     EXSRC           Extract source
00002D9E  6100 F440               2798          BSR     TSTAM           Test modes for validity
00002DA2  6600 E4E8               2799          BNE     FLAGCL          If invalid, return unsuccessful
00002DA6  6100 F460               2800          BSR     ADVBFR          Else, advance the buffer accordingly
00002DAA  6000 E4DA               2801          BRA     FLAGST          Branch to set flag
00002DAE                          2802  
00002DAE                          2803   
00002DAE                          2804  * NOT: 01000110|SZ|EMD|ERG
00002DAE                          2805  * Syntax:  NOT      <ea>
00002DAE                          2806  
00002DAE  31FC 00DB 1008          2807  BRNOT   MOVE.W  #$0DB,(IOOPCD)  Set OP-code name
00002DB4  3011                    2808          MOVE.W  (A1),D0         Move instruction to D0
00002DB6  243C 000000C0           2809          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002DBC  6100 E638               2810          BSR     EXTMSK          Get the size to D1
00002DC0                          2811  
00002DC0  B23C 0003               2812          CMP.B   #%11,D1         Compare size to 11
00002DC4  6700 E4C6               2813          BEQ     FLAGCL          If ==, it is not NOT, branch to clear flag      
00002DC8  11C1 100C               2814          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002DCC                          2815  
00002DCC                          2816          * EA field: "Only data alterable addressing modes can be used [...]."
00002DCC  303C 01FD               2817          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002DD0  6100 F5D8               2818          BSR     EXSRC           Extract destination from source location
00002DD4  6100 F40A               2819          BSR     TSTAM           Test modes for validity
00002DD8  6600 E4B2               2820          BNE     FLAGCL          If not valid, return unsuccessful
00002DDC  6100 F42A               2821          BSR     ADVBFR          Else, advance the buffer accordingly
00002DE0  6000 E4A4               2822          BRA     FLAGST          Return successful
00002DE4                          2823  
00002DE4                          2824  * RTS: 0100111001110101
00002DE4                          2825  * Syntax: RTS
00002DE4                          2826  
00002DE4  31FC 00F3 1008          2827  BRRTS   MOVE.W  #$0F3,(IOOPCD)  Set OP-code name
00002DEA  6000 E49A               2828          BRA     FLAGST          Return successful
00002DEE                          2829  
00002DEE                          2830  * RTE: 0100111001110011
00002DEE                          2831  * Syntax: RTE
00002DEE                          2832  
00002DEE  31FC 00EB 1008          2833  BRRTE   MOVE.W  #$0EB,(IOOPCD)  Set OP-code name
00002DF4  6000 E490               2834          BRA     FLAGST          Return successful
00002DF8                          2835  
00002DF8                          2836  * RTD: 0100111001110100
00002DF8                          2837  * Syntax: RTD
00002DF8                          2838  
00002DF8  31FC 00E7 1008          2839  BRRTD   MOVE.W  #$0E7,(IOOPCD)  Set OP-code name
00002DFE  6000 E486               2840          BRA     FLAGST          Return successful
00002E02                          2841  
00002E02                          2842  * RTR: 0100111001110111
00002E02                          2843  * Syntax: RTR
00002E02                          2844  
00002E02  31FC 00EF 1008          2845  BRRTR   MOVE.W  #$0EF,(IOOPCD)  Set OP-code name
00002E08  6000 E47C               2846          BRA     FLAGST          Return successful
00002E0C                          2847  
00002E0C                          2848  * NOP: 0100111001110001
00002E0C                          2849  * Syntax: NOP
00002E0C                          2850  
00002E0C  31FC 00D7 1008          2851  BRNOP   MOVE.W  #$0D7,(IOOPCD)  Set OP-code name
00002E12  6000 E472               2852          BRA     FLAGST          Return successful
00002E16                          2853  
00002E16                          2854  * TRAP: 010011100100|VECT
00002E16                          2855  * Syntax:  TRAP     #< vector >
00002E16                          2856  
00002E16  31FC 010F 1008          2857  BRTRAP  MOVE.W  #$10F,(IOOPCD)  Set OP-code name
00002E1C  11FC 0008 115A          2858          MOVE.B  #8,(SMD)        Set source mode to 3 BEARS CUSTOM
00002E22  11FC 0001 115B          2859          MOVE.B  #1,(SRG)        Set reg mode to 1 for #<data>.Q
00002E28  6000 E45C               2860          BRA     FLAGST          Return successful
00002E2C                          2861  
00002E2C                          2862  * SWAP: 0100100001000|REG
00002E2C                          2863  
00002E2C  31FC 010A 1008          2864  BRSWAP  MOVE.W  #$10A,(IOOPCD)  Set OP-code name
00002E32  6100 F576               2865          BSR     EXSRC           Extract reg from source location
00002E36  11FC 0000 115A          2866          MOVE.B  #0,(SMD)        Set mode to Dn
00002E3C  6000 E448               2867          BRA     FLAGST          Return successful
00002E40                          2868  
00002E40                          2869  * CLR: 01000010|SZ|EMD|ERG
00002E40                          2870  
00002E40  31FC 002D 1008          2871  BRCLR   MOVE.W  #$02D,(IOOPCD)  Set OP-code name
00002E46  3011                    2872          MOVE.W  (A1),D0         Move instruction to D0
00002E48  243C 000000C0           2873          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002E4E  6100 E5A6               2874          BSR     EXTMSK          Get the size to D1
00002E52  B23C 0003               2875          CMP.B   #%11,D1         Compare size to 11
00002E56  6700 E434               2876          BEQ     FLAGCL          If ==, it is not CLR, branch to clear flag      
00002E5A  11C1 100C               2877          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002E5E                          2878  
00002E5E                          2879          * EA field: "Only data alterable addressing modes can be used [...]."
00002E5E  303C 01FD               2880          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002E62  6100 F546               2881          BSR     EXSRC           Extract destination from source location
00002E66  6100 F378               2882          BSR     TSTAM           Test modes for validity
00002E6A  6600 E420               2883          BNE     FLAGCL          If not valid, return unsuccessful
00002E6E  6100 F398               2884          BSR     ADVBFR          Else, advance the buffer accordingly
00002E72  6000 E412               2885          BRA     FLAGST          Return successful
00002E76                          2886  
00002E76                          2887  * TST: 01001010|SZ|EMD|ERG
00002E76                          2888  
00002E76  31FC 0029 1008          2889  BRTST   MOVE.W  #$029,(IOOPCD)  Set OP-code name
00002E7C  3011                    2890          MOVE.W  (A1),D0         Move instruction to D0
00002E7E  243C 000000C0           2891          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002E84  6100 E570               2892          BSR     EXTMSK          Get the size to D1
00002E88  B23C 0003               2893          CMP.B   #%11,D1         Compare size to 11
00002E8C  6700 E3FE               2894          BEQ     FLAGCL          If ==, it is not CLR, branch to clear flag      
00002E90  11C1 100C               2895          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002E94                          2896  
00002E94                          2897          * EA field: Only data alterable addressing modes can be used (M68)
00002E94  303C 01FD               2898          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002E98  6100 F510               2899          BSR     EXSRC           Extract destination from source location
00002E9C  6100 F342               2900          BSR     TSTAM           Test modes for validity
00002EA0  6600 E3EA               2901          BNE     FLAGCL          If not valid, return unsuccessful
00002EA4  6100 F362               2902          BSR     ADVBFR          Else, advance the buffer accordingly
00002EA8  6000 E3DC               2903          BRA     FLAGST          Return successful
00002EAC                          2904  
00002EAC                          2905  * EXT: 0100100|OPM|000|REG
00002EAC                          2906  * Syntax:  EXT.W    Dn
00002EAC                          2907  *          EXT.L    Dn
00002EAC                          2908  
00002EAC  31FC 011C 1008          2909  BREXT   MOVE.W  #$11C,(IOOPCD)  Set OP-code name
00002EB2  6100 F4F6               2910          BSR     EXSRC           Extract mode & register
00002EB6  3011                    2911          MOVE.W  (A1),D0         Move instruction to D0
00002EB8  243C 000001C0           2912          MOVE.L  #$01C0,D2       Extract OP-mode at 0000000111000000
00002EBE  6100 E536               2913          BSR     EXTMSK          Get the OP-mode to D1
00002EC2  11FC 0001 100C          2914          MOVE.B  #1,(IOSIZE)     Set size to word
00002EC8  B23C 0002               2915          CMP.B   #2,D1           Compare OP-mode to 010
00002ECC  6700 E3B8               2916          BEQ     FLAGST          If ==, return successful
00002ED0  11FC 0002 100C          2917          MOVE.B  #2,(IOSIZE)     Set size to long
00002ED6  B23C 0003               2918          CMP.B   #3,D1           Compare OP-mode to 011
00002EDA  6700 E3AA               2919          BEQ     FLAGST          If ==, return successful
00002EDE  6000 E3AC               2920          BRA     FLAGCL          Else, return unsuccessful
00002EE2                          2921  
00002EE2                          2922  * NEG: 01000100|SZ|EMD|ERG
00002EE2                          2923  * Syntax:  NEG      <ea>
00002EE2                          2924  
00002EE2  31FC 0120 1008          2925  BRNEG   MOVE.W  #$120,(IOOPCD)  Set OP-code name
00002EE8  3011                    2926          MOVE.W  (A1),D0         Move instruction to D0
00002EEA  243C 000000C0           2927          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002EF0  6100 E504               2928          BSR     EXTMSK          Get the size to D1
00002EF4  B23C 0003               2929          CMP.B   #%11,D1         Compare size to 11
00002EF8  6700 E392               2930          BEQ     FLAGCL          If ==, it is not CLR, branch to clear flag      
00002EFC  11C1 100C               2931          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002F00                          2932  
00002F00                          2933          * EA field: Only data alterable addressing modes can be used (M68)
00002F00  303C 01FD               2934          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002F04  6100 F4A4               2935          BSR     EXSRC           Extract destination from source location
00002F08  6100 F2D6               2936          BSR     TSTAM           Test modes for validity
00002F0C  6600 E37E               2937          BNE     FLAGCL          If not valid, return unsuccessful
00002F10  6100 F2F6               2938          BSR     ADVBFR          Else, advance the buffer accordingly
00002F14  6000 E370               2939          BRA     FLAGST          Return successful
00002F18                          2940  
00002F18                          2941  ELOC    
00002F18                          2942          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 12C4
A2H11               12FC
A2H12               1302
A2H13               1308
A2H14               130E
A2H15               1314
A2H16               131A
A2HADV              12F4
ADVBFR              2208
ADVBSZ              2262
ASCII2HEX           1292
BADADV              1C3E
BCCTBL              2770
BEXTW               14E6
BRADD               24E6
BRADDA              2532
BRADDI              24C8
BRADDQ              255E
BRAND               25EA
BRANDI              24B4
BRARMQ              23FE
BRARW               2D8A
BRASD               2C64
BRBAD               1C24
BRBCC               27F0
BRBCCD              2728
BRBCS               27FA
BRBEQ               27B4
BRBGE               282C
BRBGT               2836
BRBHI               27D2
BRBLE               2840
BRBLS               284A
BRBLT               27BE
BRBMI               2822
BRBNE               27C8
BRBPL               2818
BRBRA               27DC
BRBSR               27E6
BRBTST              2682
BRBTSTD             26F2
BRBTSTS             26A4
BRBVC               2804
BRBVS               280E
BRCLR               2E40
BRCMP               296C
BRCMPA              29A6
BRCMPI              24DC
BRDBCC              28F4
BRDBCCD             2854
BRDBCS              28FE
BRDBEQ              2912
BRDBF               28D6
BRDBGE              2944
BRDBGT              2958
BRDBHI              28E0
BRDBLE              2962
BRDBLS              28EA
BRDBLT              294E
BRDBMI              293A
BRDBNE              2908
BRDBPL              2930
BRDBT               28CC
BRDBVC              291C
BRDBVS              2926
BRDIVS              2D7A
BRDIVU              2D6A
BREOR               29D2
BREORI              24D2
BREXT               2EAC
BRIMCCR             248C
BRIMM               243A
BRJMP               2A4E
BRJSR               2A30
BRLEA               2A08
BRLSD               2C94
BRMAD               2D28
BRMFCCR             2AE2
BRMOVE              2A6C
BRMOVEA             2B46
BRMOVEM             2B72
BRMOVEQ             2C0E
BRMTCCR             2B16
BRMULS              2D5A
BRMULU              2D4A
BRNEG               2EE2
BRNOP               2E0C
BRNOT               2DAE
BROR                2636
BRORI               24AC
BRRAD               2CC4
BRROD               2C34
BRRTD               2DF8
BRRTE               2DEE
BRRTR               2E02
BRRTS               2DE4
BRSUB               2568
BRSUBA              25B4
BRSUBI              24BE
BRSUBQ              25E0
BRSWAP              2E2C
BRTRAP              2E16
BRTST               2E76
CHKEND              1D78
CMPMSK              13C8
COMMENT             1014
CR                  D
D3BTBL              1870
DBCCTBL             2888
DIS                 115D
DISPADR             1B80
DISPANO             1BEA
DISPBD              1BC6
DISPC0              1898
DISPC1              18C2
DISPC2              18E2
DISPC3              1902
DISPC4              1918
DISPC5              192C
DISPC6              193E
DISPC7              19CC
DISPC8              1A5E
DISPC9              1A76
DISPDAT             1CA6
DISPDIS             1574
DISPDST             1B60
DISPINS             1AF0
DISPM0              1656
DISPM1              1668
DISPM2              1670
DISPM3              1688
DISPM4              16A6
DISPM5              16C4
DISPM6              16F8
DISPM7              1744
DISPM8              1868
DISPM9              1A9A
DISPMA              1AAE
DISPMB              1AC2
DISPMC              1AD6
DISPOP              1612
DISPR0              1764
DISPR1              1780
DISPR2              179C
DISPR3              17D4
DISPR4              1824
DISPR5              1856
DISPRAW             1B9A
DISPRT              1AEA
DISPSRC             1B40
DMD                 1158
DMDTBL              1622
DONE                1E02
DRG                 1159
DRGTBL              174C
DSPAN               14B8
DSPAX               140E
DSPHADV             146E
DSPHDR              1DD4
DSPHST              145A
DSPHXA              1418
DSPHXB              143E
DSPHXL              1478
DSPHXLP             141C
DSPHXRT             1438
DSPHXW              1452
DSPSP               14D4
DSPSTLP             148C
DSPSTR              1482
DSPSTRT             14A4
ELOC                2F18
EXDST               2374
EXSRC               23AA
EXTADV              1408
EXTLP               13FC
EXTMSK              13F6
FLAGCL              128C
FLAGST              1286
GBUFF               1000
H2A                 1352
H2AA                138A
H2AADV              1382
H2AB                1390
H2AC                1396
H2AD                139C
H2AE                13A2
H2AF                13A8
HALT                1E32
HEADR               11F3
HEX2ASCII           1320
IOADDR              100E
IOBC                1013
IOBDCD              100A
IOLC                1012
IOOPCD              1008
IOOPSZ              114C
IOSIZE              100C
JMPMSK              1E38
LF                  A
MASK                13AE
MLRADV              1A44
MLRDEC              1A08
MLRLP               19E6
MLRNXT              1A4E
MSSG4               115E
MSSG5               11A2
M_ALL               FFF
M_ALT               7F
M_CTR               7E4
M_DALT              1FD
M_DAT               FFD
M_EAALT             1FF
M_MALT              1FC
M_MEM               FFC
NEWBAD              1C86
NGBUFF              1004
NOTBAD              1CD8
OP                  1E50
OP0                 22CC
OP1                 22DE
OP2                 22F0
OP3                 2302
OP4                 2314
OP5                 2326
OP6                 2338
OP7                 234A
OP8                 235C
OPNAME              1028
OPSIZE              229A
OPTBL               22AC
PAUSE               1D88
PRINT               1C64
PRINTD              1CFC
PRINTS              1CEE
PRNTFIN             1D1A
REQKEY              1D9C
RESETIO             1D4C
RGMD                115C
RLMADV              19B2
RLMINC              1976
RLMLP               1956
RLMNXT              19BC
SC0                 1528
SC1                 1530
SC2                 1538
SC3                 1540
SC4                 1548
SCTBL               1518
SMD                 115A
SRG                 115B
START               1246
SWAPF               23D8
TSTAM               21E0
TSTBAD              1C0C
TSTMSK              13B4
